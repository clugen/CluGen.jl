<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Theory · CluGen documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="CluGen documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">CluGen documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Theory</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Detailed-description"><span>Detailed description</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../dev/">Development</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Theory</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Theory</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/clugen/CluGen.jl/blob/main/docs/src/theory.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Theory"><a class="docs-heading-anchor" href="#Theory">Theory</a><a id="Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Theory" title="Permalink"></a></h1><p>This section describes the theoretical framework of the <em>clugen</em> algorithm, starting with a general <a href="#Overview">Overview</a>, then moving on to a <a href="#Detailed-description">Detailed description</a>.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p><em>Clugen</em> is an algorithm for generating multidimensional clusters. Each cluster is supported by a line segment, the position, orientation and length of which guide where the respective points are placed. For brevity, <em>line segments</em> will be referred to as <em>lines</em>.</p><p>Given an <span>$n$</span>-dimensional direction vector <span>$\mathbf{d}$</span> (and a number of additional parameters, which will be discussed shortly), the <em>clugen</em> algorithm works as follows (<span>$^*$</span> means the algorithm step is stochastic):</p><ol><li>Normalize <span>$\mathbf{d}$</span>.</li><li><span>$^*$</span>Determine cluster sizes.</li><li><span>$^*$</span>Determine cluster centers.</li><li><span>$^*$</span>Determine lengths of cluster-supporting lines.</li><li><span>$^*$</span>Determine angles between <span>$\mathbf{d}$</span> and cluster-supporting lines.</li><li>For each cluster:<ol><li><span>$^*$</span>Determine direction of the cluster-supporting line.</li><li><span>$^*$</span>Determine distance of point projections from the center of the cluster-supporting line.</li><li>Determine coordinates of point projections on the cluster-supporting line.</li><li><span>$^*$</span>Determine points from their projections on the cluster-supporting line.</li></ol></li></ol><p>Figure 1 provides a stylized overview of the algorithm&#39;s steps.</p><p><img src="../algorithm.svg" alt/> <strong>Figure 1</strong> - Stylized overview of the <em>clugen</em> algorithm. Background tiles are 10 units wide and tall, when applicable.</p><p>The example in Figure 1 was generated with the following parameters, the exact meaning of each will be discussed shortly:</p><table><tr><th style="text-align: left">Parameter values</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><span>$n=2$</span></td><td style="text-align: left">Number of dimensions.</td></tr><tr><td style="text-align: left"><span>$c=4$</span></td><td style="text-align: left">Number of clusters.</td></tr><tr><td style="text-align: left"><span>$p=200$</span></td><td style="text-align: left">Total number of points.</td></tr><tr><td style="text-align: left"><span>$\mathbf{d}=\begin{bmatrix}1 &amp; 1\end{bmatrix}^T$</span></td><td style="text-align: left">Average direction.</td></tr><tr><td style="text-align: left"><span>$\theta_\sigma=\pi/16\approx{}11.25^{\circ}$</span></td><td style="text-align: left">Angle dispersion.</td></tr><tr><td style="text-align: left"><span>$\mathbf{s}=\begin{bmatrix}10 &amp; 10\end{bmatrix}^T$</span></td><td style="text-align: left">Average cluster separation.</td></tr><tr><td style="text-align: left"><span>$l=10$</span></td><td style="text-align: left">Average line length.</td></tr><tr><td style="text-align: left"><span>$l_\sigma=1.5$</span></td><td style="text-align: left">Line length dispersion.</td></tr><tr><td style="text-align: left"><span>$f_\sigma=1$</span></td><td style="text-align: left">Cluster lateral dispersion.</td></tr></table><p>Additionally, all optional parameters (not listed above) were left to their default values. These will also be discussed next. This example can be reproduced and plotted with the following instructions (the <a href="https://github.com/JuliaRandom/StableRNGs.jl">StableRNGs</a> package is used to keep the example reproducible between Julia versions):</p><pre><code class="language-julia-repl hljs">julia&gt; using CluGen, Plots, StableRNGs

julia&gt; r = clugen(2, 4, 200, [1, 1], pi/16, [10, 10], 10, 1.5, 1; rng = StableRNG(9999));

julia&gt; plot(r.points[:,1], r.points[:,2], seriestype = :scatter, group=r.clusters)</code></pre><h2 id="Detailed-description"><a class="docs-heading-anchor" href="#Detailed-description">Detailed description</a><a id="Detailed-description-1"></a><a class="docs-heading-anchor-permalink" href="#Detailed-description" title="Permalink"></a></h2><p>In this section we provide a detailed description of the algorithm and its parameters. We start by listing and describing all parameters (mandatory and optional), and then analyze the algorithm in detail, highlighting how each parameter influences the end result.</p><h3 id="Algorithm-parameters"><a class="docs-heading-anchor" href="#Algorithm-parameters">Algorithm parameters</a><a id="Algorithm-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-parameters" title="Permalink"></a></h3><p>The <em>clugen</em> algorithm (and consequently, the <a href="../reference/#CluGen.clugen"><code>clugen()</code></a> function) has mandatory and optional parameters, listed and described in the tables below. The optional parameters are set to sensible defaults, and in many situations may be left unchanged. Nonetheless, these allow all of the algorithm&#39;s steps to be fully customized by the user.</p><h4 id="Mandatory-parameters"><a class="docs-heading-anchor" href="#Mandatory-parameters">Mandatory parameters</a><a id="Mandatory-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Mandatory-parameters" title="Permalink"></a></h4><table><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Parameter</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><span>$n$</span></td><td style="text-align: left"><code>num_dims</code></td><td style="text-align: left">Number of dimensions.</td></tr><tr><td style="text-align: left"><span>$c$</span></td><td style="text-align: left"><code>num_clusters</code></td><td style="text-align: left">Number of clusters.</td></tr><tr><td style="text-align: left"><span>$p$</span></td><td style="text-align: left"><code>num_points</code></td><td style="text-align: left">Total number of points to generate.</td></tr><tr><td style="text-align: left"><span>$\mathbf{d}$</span></td><td style="text-align: left"><code>direction</code></td><td style="text-align: left">Average direction of cluster-supporting lines (<span>$n \times 1$</span>).</td></tr><tr><td style="text-align: left"><span>$\theta_\sigma$</span></td><td style="text-align: left"><code>angle_disp</code></td><td style="text-align: left">Angle dispersion of cluster-supporting lines (radians).</td></tr><tr><td style="text-align: left"><span>$\mathbf{s}$</span></td><td style="text-align: left"><code>cluster_sep</code></td><td style="text-align: left">Average cluster separation in each dimension (<span>$n \times 1$</span>).</td></tr><tr><td style="text-align: left"><span>$l$</span></td><td style="text-align: left"><code>llength</code></td><td style="text-align: left">Average length of cluster-supporting lines.</td></tr><tr><td style="text-align: left"><span>$l_\sigma$</span></td><td style="text-align: left"><code>llength_disp</code></td><td style="text-align: left">Length dispersion of cluster-supporting lines.</td></tr><tr><td style="text-align: left"><span>$f_\sigma$</span></td><td style="text-align: left"><code>lateral_disp</code></td><td style="text-align: left">Cluster lateral dispersion, i.e., dispersion of points from their projection on the cluster-supporting line.</td></tr></table><h4 id="Optional-parameters"><a class="docs-heading-anchor" href="#Optional-parameters">Optional parameters</a><a id="Optional-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-parameters" title="Permalink"></a></h4><table><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Parameter</th><th style="text-align: left">Default value</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><span>$\phi$</span></td><td style="text-align: left"><code>allow_empty</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">Allow empty clusters?</td></tr><tr><td style="text-align: left"><span>$\mathbf{o}$</span></td><td style="text-align: left"><code>cluster_offset</code></td><td style="text-align: left"><code>zeros(num_dims)</code></td><td style="text-align: left">Offset to add to all cluster centers (<span>$n \times 1$</span>).</td></tr><tr><td style="text-align: left"><span>$p_\text{proj}()$</span></td><td style="text-align: left"><code>proj_dist_fn</code></td><td style="text-align: left"><code>&quot;norm&quot;</code></td><td style="text-align: left">Distribution of point projections along cluster-supporting lines.</td></tr><tr><td style="text-align: left"><span>$p_\text{final}()$</span></td><td style="text-align: left"><code>point_dist_fn</code></td><td style="text-align: left"><code>&quot;n-1&quot;</code></td><td style="text-align: left">Distribution of final points from their projections.</td></tr><tr><td style="text-align: left"><span>$c_s()$</span></td><td style="text-align: left"><code>clusizes_fn</code></td><td style="text-align: left"><a href="../reference/#CluGen.clusizes"><code>CluGen.clusizes()</code></a></td><td style="text-align: left">Distribution of cluster sizes.</td></tr><tr><td style="text-align: left"><span>$c_c()$</span></td><td style="text-align: left"><code>clucenters_fn</code></td><td style="text-align: left"><a href="../reference/#CluGen.clucenters"><code>CluGen.clucenters()</code></a></td><td style="text-align: left">Distribution of cluster centers.</td></tr><tr><td style="text-align: left"><span>$l()$</span></td><td style="text-align: left"><code>llengths_fn</code></td><td style="text-align: left"><a href="../reference/#CluGen.llengths"><code>CluGen.llengths()</code></a></td><td style="text-align: left">Distribution of line lengths.</td></tr><tr><td style="text-align: left"><span>$\theta_\Delta()$</span></td><td style="text-align: left"><code>angle_deltas_fn</code></td><td style="text-align: left"><a href="../reference/#CluGen.angle_deltas"><code>CluGen.angle_deltas()</code></a></td><td style="text-align: left">Distribution of line angle deltas (w.r.t. <span>$\mathbf{d}$</span>).</td></tr></table><h3 id="The-algorithm-in-detail"><a class="docs-heading-anchor" href="#The-algorithm-in-detail">The algorithm in detail</a><a id="The-algorithm-in-detail-1"></a><a class="docs-heading-anchor-permalink" href="#The-algorithm-in-detail" title="Permalink"></a></h3><p>The <em>clugen</em> algorithm is presented in <a href="#Overview">Overview</a>. In this section we will analyze each of the algorithms steps in detail.</p><h4 id=".-Normalize-\\mathbf{d}"><a class="docs-heading-anchor" href="#.-Normalize-\\mathbf{d}">1. Normalize <span>$\mathbf{d}$</span></a><a id=".-Normalize-\\mathbf{d}-1"></a><a class="docs-heading-anchor-permalink" href="#.-Normalize-\\mathbf{d}" title="Permalink"></a></h4><p>This is a basic step, which consists of converting <span>$\mathbf{d}$</span> to a unit vector:</p><p class="math-container">\[\hat{\mathbf{d}} = \cfrac{\mathbf{d}}{\left\lVert\mathbf{d}\right\rVert}\]</p><h4 id=".-Determine-cluster-sizes"><a class="docs-heading-anchor" href="#.-Determine-cluster-sizes">2. Determine cluster sizes</a><a id=".-Determine-cluster-sizes-1"></a><a class="docs-heading-anchor-permalink" href="#.-Determine-cluster-sizes" title="Permalink"></a></h4><p>Cluster sizes are given by the <span>$c_s()$</span> function according to:</p><p class="math-container">\[\mathbf{c_s} = c_s(c, p, \phi)\]</p><p>where <span>$\mathbf{c_s}$</span> is an <span>$c \times 1$</span> integer vector containing the final cluster sizes, <span>$c$</span> is the number of clusters, <span>$p$</span> is the total number of points, and <span>$\phi$</span> is a boolean which determines whether empty clusters are acceptable.</p><p>The <span>$c_s()$</span> function is an optional parameter, allowing users to customize its behavior. By default, <span>$c_s()$</span> is implemented by the <a href="../reference/#CluGen.clusizes"><code>CluGen.clusizes()</code></a> function, which behaves according to the following algorithm:</p><ol><li>Determine the size <span>$p_i$</span> of each cluster <span>$i$</span> according to <span>$p_i\sim\left\lfloor\max\left(\mathcal{N}(\frac{p}{c}, (\frac{p}{3c})^2),0\right)\right\rceil$</span>, where <span>$\lfloor\rceil$</span> denotes the round to nearest integer function, and  <span>$\mathcal{N}(\mu,\sigma^2)$</span> represents the normal distribution with mean <span>$\mu$</span> and variance <span>$\sigma^2$</span>.</li><li>Assure that the final cluster sizes add up to <span>$p$</span> by incrementing the smallest cluster size while <span>$\sum_{i=1}^c p_i&lt;p$</span> or decrementing the largest cluster size while <span>$\sum_{i=1}^c p_i&gt;p$</span>. This step is delegated to the <a href="../reference/#CluGen.fix_num_points!"><code>CluGen.fix_num_points!()</code></a> helper function.</li><li>If <span>$\neg\phi\wedge p\ge c$</span> then, for each empty cluster <span>$i$</span> (i.e., <span>$p_i=0$</span>), increment <span>$p_i$</span> and decrement <span>$p_j$</span>, where <span>$j$</span> denotes the largest cluster. This step is delegated to the <a href="../reference/#CluGen.fix_empty!"><code>CluGen.fix_empty!()</code></a> helper function.</li></ol><p>Figure 2 demonstrates possible cluster sizes with various definitions of <span>$c_s()$</span> for <span>$c=4$</span> and <span>$p=5000$</span>. The default behavior, implemented in the <a href="../reference/#CluGen.clusizes"><code>CluGen.clusizes()</code></a> function, is shown in Figure 2a, while Figures 2b-d present results obtained with custom user functions. Figure 2b displays cluster sizes obtained with the discrete uniform distribution over <span>$\left\{1, 2, \ldots, \frac{2p}{c}\right\}$</span>, corrected with <a href="../reference/#CluGen.fix_num_points!"><code>CluGen.fix_num_points!()</code></a>. In turn, Figure 2c highlights cluster sizes obtained with the Poisson distribution with <span>$\lambda=\frac{p}{c}$</span>, also corrected with <a href="../reference/#CluGen.fix_num_points!"><code>CluGen.fix_num_points!()</code></a>. The cluster sizes shown in Figure 2d were determined with the same distribution (Poisson, <span>$\lambda=\frac{p}{c}$</span>), but were not corrected. Thus, cluster sizes do not add up to <span>$p$</span>, highlighting the fact that this is not a requirement of the <em>clugen</em> algorithm, i.e., user-defined  <span>$c_s()$</span> implementations can consider <span>$p$</span> a hint rather than an obligation.</p><p><img src="../clusizes.svg" alt/> <strong>Figure 2</strong> - Possible cluster sizes with various definitions of <span>$c_s()$</span> for <span>$c=4$</span> and <span>$p=5000$</span>.</p><h4 id=".-Determine-cluster-centers"><a class="docs-heading-anchor" href="#.-Determine-cluster-centers">3. Determine cluster centers</a><a id=".-Determine-cluster-centers-1"></a><a class="docs-heading-anchor-permalink" href="#.-Determine-cluster-centers" title="Permalink"></a></h4><p>Cluster sizes are given by the <span>$c_c()$</span> function according to:</p><p class="math-container">\[\mathbf{C} = c_c(c, \mathbf{s}, \mathbf{o})\]</p><p>where <span>$\mathbf{C}$</span> is an <span>$c \times n$</span> matrix containing the final cluster centers, <span>$c$</span> is the number of clusters, <span>$\mathbf{s}$</span> is the average cluster separation (<span>$n \times 1$</span> vector), and <span>$\mathbf{o}$</span> is an <span>$n \times 1$</span> vector of cluster offsets.</p><p>The <span>$c_c()$</span> function is an optional parameter, allowing users to customize its behavior. By default, <span>$c_c()$</span> is implemented by the <a href="../reference/#CluGen.clucenters"><code>CluGen.clucenters()</code></a> function, which determines the cluster centers according to:</p><p class="math-container">\[\mathbf{C}=c\mathbf{U} \cdot \operatorname{diag}(\mathbf{s}) + \mathbf{1}\,\mathbf{o}^T\]</p><p>where <span>$\mathbf{U}$</span> is an <span>$c \times n$</span> matrix of random values drawn from the uniform distribution between -0.5 and 0.5, and <span>$\mathbf{1}$</span> is an <span>$c \times 1$</span> vector with all entries equal to 1.</p><p>Figure 3 shows scatters plots of the results generated by <em>clugen</em> for two different implementations of the <span>$c_c()$</span> function, namely using the uniform the distribution (the default, implemented by the <a href="../reference/#CluGen.clucenters"><code>CluGen.clucenters()</code></a> function, Figure 3a), and direct specification of cluster centers (Figure 3b).</p><p><img src="../clucenters.svg" alt/> <strong>Figure 3</strong> - The output of <em>clugen</em> for two different implementations of the <span>$c_c()$</span> function for finding cluster centers: a) the default, using the uniform distribution; b) hand-picked centers. All parameters are the same as in Figure 1, except for <span>$p$</span>, which is set to 5000.</p><h4 id=".-Determine-lengths-of-cluster-supporting-lines"><a class="docs-heading-anchor" href="#.-Determine-lengths-of-cluster-supporting-lines">4. Determine lengths of cluster-supporting lines</a><a id=".-Determine-lengths-of-cluster-supporting-lines-1"></a><a class="docs-heading-anchor-permalink" href="#.-Determine-lengths-of-cluster-supporting-lines" title="Permalink"></a></h4><p>The lengths of the cluster-supporting lines are given by the <span>$l()$</span> function according to:</p><p class="math-container">\[\pmb{\ell} = l(c, l, l_\sigma)\]</p><p>where <span>$\pmb{\ell}$</span> is an <span>$c \times 1$</span> vector containing the final lengths of the cluster-supporting lines, <span>$c$</span> is the number of clusters, <span>$l$</span> is the average length, and <span>$l_\sigma$</span> is the length dispersion.</p><p>The <span>$l()$</span> function is an optional parameter, allowing users to customize its behavior. By default, <span>$l()$</span> is implemented by the <a href="../reference/#CluGen.llengths"><code>CluGen.llengths()</code></a> function, which determines the <span>$\ell_i$</span> length of each cluster-supporting line <span>$i$</span> according to:</p><p class="math-container">\[\ell_i\sim\left|\mathcal{N}(l,l_\sigma^2)\right|\]</p><p>where <span>$\left|\mathcal{N}(\mu,\sigma^2)\right|$</span> represents the folded normal distribution with mean <span>$\mu$</span> and variance <span>$\sigma^2$</span>.</p><p>Figure 4 shows cluster-supporting line lengths obtained with different implementations of <span>$l()$</span>.</p><p><img src="../llengths.svg" alt/> <strong>Figure 4</strong> - Line lengths for different implementations of <span>$l()$</span>: a) the default, using the folded normal distribution; b) using the Poisson distribution, with <span>$\lambda=l$</span>; c) using the uniform distribution in the interval <span>$\left[0, 2l\right[$</span>; and, d) hand-picked lengths, more specifically <span>$\pmb{\ell}=\begin{bmatrix}2 &amp; 8 &amp; 16 &amp; 32\end{bmatrix}^T$</span>. Cluster centers, as well as parameters <span>$l$</span> and <span>$l_\sigma$</span>, are the same as for the example shown in Figure 1.</p><h4 id=".-Determine-angles-between-\\mathbf{d}-and-cluster-supporting-lines"><a class="docs-heading-anchor" href="#.-Determine-angles-between-\\mathbf{d}-and-cluster-supporting-lines">5. Determine angles between <span>$\mathbf{d}$</span> and cluster-supporting lines</a><a id=".-Determine-angles-between-\\mathbf{d}-and-cluster-supporting-lines-1"></a><a class="docs-heading-anchor-permalink" href="#.-Determine-angles-between-\\mathbf{d}-and-cluster-supporting-lines" title="Permalink"></a></h4><p>The angles between <span>$\mathbf{d}$</span> and the cluster-supporting lines are given by the <span>$\theta_\Delta()$</span> function according to:</p><p class="math-container">\[\mathbf{\Theta_\Delta} = \theta_\Delta(c, \theta_\sigma)\]</p><p>where <span>$\mathbf{\Theta_\Delta}$</span> is an <span>$c \times 1$</span> vector containing the final angle differences between <span>$\mathbf{d}$</span> and the cluster-supporting lines, <span>$c$</span> is the number of clusters, and <span>$\theta_\sigma$</span> is the angle dispersion.</p><p>The <span>$\theta_\Delta()$</span> function is an optional parameter, allowing users to customize its behavior. By default, <span>$\theta_\Delta()$</span> is implemented by the <a href="../reference/#CluGen.angle_deltas"><code>CluGen.angle_deltas()</code></a> function, which determines the <span>$\theta_{\Delta i}$</span> angle difference between <span>$\mathbf{d}$</span> and the <span>$i$</span>-th  cluster-supporting line according to:</p><p class="math-container">\[\theta_{\Delta i}\sim\mathcal{WN}_{-\pi/2}^{\pi/2}(0,\theta_\sigma^2)\]</p><p>where <span>$\mathcal{WN}_{-\pi/2}^{\pi/2}(\mu,\sigma^2)$</span> represents the wrapped normal distribution with mean <span>$\mu$</span>, variance <span>$\sigma^2$</span>, and support in the <span>$\left[-\pi/2,\pi/2\right]$</span> interval, and <span>$\theta_\sigma$</span> is the angle dispersion of the cluster-supporting lines.</p><p>Figure 5 shows the final direction of the cluster-supporting lines for two different implementations of <span>$\theta_\Delta()$</span>.</p><p><img src="../angle_deltas.svg" alt/> <strong>Figure 5</strong> - Final directions of the cluster supporting-lines for different implementations of <span>$\theta_\Delta()$</span>: a) the default, where angle differences were obtained using the wrapped normal distribution; and, d) hand-picked angle differences, more specifically <span>$\mathbf{\Theta_\Delta}=\begin{bmatrix}0 &amp; \frac{\pi}{2} &amp; 0 &amp; \frac{\pi}{2}\end{bmatrix}^T$</span>. Cluster centers, as well as the angle dispersion <span>$\theta_\sigma$</span>, are the same as for the example shown in Figure 1.</p><h4 id=".-For-each-cluster-i:"><a class="docs-heading-anchor" href="#.-For-each-cluster-i:">6. For each cluster <span>$i$</span>:</a><a id=".-For-each-cluster-i:-1"></a><a class="docs-heading-anchor-permalink" href="#.-For-each-cluster-i:" title="Permalink"></a></h4><h5 id=".1.-Determine-direction-of-the-cluster-supporting-line"><a class="docs-heading-anchor" href="#.1.-Determine-direction-of-the-cluster-supporting-line">6.1. Determine direction of the cluster-supporting line</a><a id=".1.-Determine-direction-of-the-cluster-supporting-line-1"></a><a class="docs-heading-anchor-permalink" href="#.1.-Determine-direction-of-the-cluster-supporting-line" title="Permalink"></a></h5><p>In order to obtain the <span>$\hat{\mathbf{d}}_i$</span> final direction of cluster <span>$i$</span> supporting line, the following algorithm is used:</p><ul><li><strong>1.</strong> Find random vector <span>$\mathbf{r}$</span> with each component taken from the uniform distribution between -0.5 and 0.5.</li><li><strong>2.</strong> Normalize <span>$\mathbf{r}$</span>:<p class="math-container">\[\hat{\mathbf{r}}=\cfrac{\mathbf{r}}{\left\lVert\mathbf{r}\right\rVert}\]</p></li><li><strong>3.</strong> If <span>$|\theta_{\Delta i}| &gt; \pi/2$</span> or <span>$n=1$</span>, set <span>$\hat{\mathbf{d}}_i=\hat{\mathbf{r}}$</span> and terminate the algorithm.</li><li><strong>4.</strong> If <span>$\hat{\mathbf{r}}$</span> is parallel to <span>$\hat{\mathbf{d}}$</span> go to <strong>1</strong>.</li><li><strong>5.</strong> Determine vector <span>$\mathbf{d}_\perp$</span> orthogonal to <span>$\hat{\mathbf{d}}$</span> using the first iteration of the Gram-Schmidt process:<p class="math-container">\[\mathbf{d}_\perp=\hat{\mathbf{r}}-\cfrac{\hat{\mathbf{d}}\cdot\hat{\mathbf{r}}}{\hat{\mathbf{d}}\cdot\hat{\mathbf{d}}}\:\hat{\mathbf{d}}\]</p></li><li><strong>6.</strong> Normalize <span>$\mathbf{d}_\perp$</span>:<p class="math-container">\[\hat{\mathbf{d}}_\perp=\cfrac{\mathbf{d}_\perp}{\left\lVert\mathbf{d}_\perp\right\rVert}\]</p></li><li><strong>7.</strong> Determine vector <span>$\mathbf{d}_i$</span> at angle <span>$\theta_{\Delta i}$</span> with <span>$\hat{\mathbf{d}}$</span>:<p class="math-container">\[\mathbf{d}_i=\hat{\mathbf{d}}+\tan(\theta_{\Delta i})\hat{\mathbf{d}}_\perp\]</p></li><li><strong>8.</strong> Normalize <span>$\mathbf{d}_i$</span>:<p class="math-container">\[\hat{\mathbf{d}}_i=\cfrac{\mathbf{d}_i}{\left\lVert\mathbf{d}_i\right\rVert}\]</p></li></ul><h5 id=".2.-Determine-distance-of-point-projections-from-the-center-of-the-cluster-supporting-line"><a class="docs-heading-anchor" href="#.2.-Determine-distance-of-point-projections-from-the-center-of-the-cluster-supporting-line">6.2. Determine distance of point projections from the center of the cluster-supporting line</a><a id=".2.-Determine-distance-of-point-projections-from-the-center-of-the-cluster-supporting-line-1"></a><a class="docs-heading-anchor-permalink" href="#.2.-Determine-distance-of-point-projections-from-the-center-of-the-cluster-supporting-line" title="Permalink"></a></h5><p>The distance of point projections from the center of the cluster-supporting line is given by the <span>$p_\text{proj}()$</span> function according to:</p><p class="math-container">\[\mathbf{w}_i = p_\text{proj}(\ell_i, p_i)\]</p><p>where <span>$\mathbf{w}_i$</span> is an <span>$p_i \times 1$</span> vector containing the distance of each point projection to the center of the line, while <span>$\ell_i$</span> and <span>$p_i$</span> are the line length and number of points in cluster <span>$i$</span>, respectively.</p><p>The <span>$p_\text{proj}()$</span> function is an optional parameter, allowing users to customize its behavior. <code>CluGen.jl</code> provides two concrete implementations out of the box, specified in Julia by passing <code>&quot;norm&quot;</code> or <code>&quot;unif&quot;</code> to  <a href="../reference/#CluGen.clugen"><code>clugen()</code></a>&#39;s <code>proj_dist_fn</code> parameter. These work as follows:</p><ul><li><code>&quot;norm&quot;</code> (default) - Each element of <span>$\mathbf{w}_i$</span> is derived from <span>$\mathcal{N}(0, (\frac{\ell_i}{6})^2)$</span>, i.e., from the normal distribution, centered on the cluster-supporting line center (<span>$\mu=0$</span>) and with a standard deviation of <span>$\sigma=\frac{\ell_i}{6}$</span>, such that the length of the line segment encompasses <span>$\approx$</span> 99.73% of the generated projections. Consequently, some projections may be placed outside the line&#39;s end points.</li><li><code>&quot;unif&quot;</code> - Each element of <span>$\mathbf{w}_i$</span> is derived from <span>$\mathcal{U}(-\frac{\ell_i}{2}, \frac{\ell_i}{2})$</span>, i.e., from the continuous uniform distribution in the interval <span>$\left[-\frac{\ell_i}{2}, \frac{\ell_i}{2}\right[$</span>. Thus, projections will be uniformly dispersed along the cluster-supporting line.</li></ul><p>The impact of various implementations of <span>$p_\text{proj}()$</span> is demonstrated in Figure 6. Figures 6a and 6b show the clusters generated with the <code>&quot;norm&quot;</code> and <code>&quot;unif&quot;</code> options, respectively, while Figures 6c and 6d highlight custom user functions implementing the Laplace and Rayleigh distributions, respectively. All parameters are set as in Figure 1, except for <span>$p_\text{proj}()$</span> in the case of Figures 6b-6d, and <span>$p$</span>, which is set to 5000.</p><p><img src="../proj_dist_fn.svg" alt/> <strong>Figure 6</strong> - Clusters generated for various implementations of <span>$p_\text{proj}()$</span>: a) the default, where line center distances are drawn for the normal distribution, specified using the in-built <code>&quot;norm&quot;</code> option; b) in which center distances are derived from the uniform distribution, via the in-built <code>&quot;unif&quot;</code> option; c) where line center distances are obtained from a custom user function implementing the Laplace distribution; and, d) in which a custom user function returns center distances drawn from the Rayleigh distribution. All parameters are set as in Figure 1, except for <span>$p_\text{proj}()$</span> in the case of Figures 6b-6d, and <span>$p$</span>, which is set to 5000.</p><h5 id=".3.-Determine-coordinates-of-point-projections-on-the-cluster-supporting-line"><a class="docs-heading-anchor" href="#.3.-Determine-coordinates-of-point-projections-on-the-cluster-supporting-line">6.3. Determine coordinates of point projections on the cluster-supporting line</a><a id=".3.-Determine-coordinates-of-point-projections-on-the-cluster-supporting-line-1"></a><a class="docs-heading-anchor-permalink" href="#.3.-Determine-coordinates-of-point-projections-on-the-cluster-supporting-line" title="Permalink"></a></h5><p>This is a deterministic step performed by the <a href="../reference/#CluGen.points_on_line"><code>points_on_line()</code></a> function using the vector formulation of the line equation, as follows:</p><p class="math-container">\[\mathbf{P}_i^\text{proj}=\mathbf{1}\,\mathbf{c}_i^T + \mathbf{w}_i\hat{\mathbf{d}}_i^T\]</p><p>where <span>$\mathbf{P}_i^\text{proj}$</span> is the <span>$p_i \times n$</span> matrix of point projection coordinates on the line, <span>$\mathbf{1}$</span> is an <span>$p_i \times 1$</span> vector with all entries equal to 1, <span>$\mathbf{c}_i$</span> are the coordinates of the line center (<span>$n \times 1$</span> vector), <span>$\mathbf{w}_i$</span> is the distance of each point projection to the center of the line (<span>$p_i \times 1$</span> vector obtained in the previous step), and <span>$\hat{\mathbf{d}}_i$</span> is the direction of the cluster-supporting line for cluster <span>$i$</span>.</p><h5 id=".4.-Determine-points-from-their-projections-on-the-cluster-supporting-line"><a class="docs-heading-anchor" href="#.4.-Determine-points-from-their-projections-on-the-cluster-supporting-line">6.4. Determine points from their projections on the cluster-supporting line</a><a id=".4.-Determine-points-from-their-projections-on-the-cluster-supporting-line-1"></a><a class="docs-heading-anchor-permalink" href="#.4.-Determine-points-from-their-projections-on-the-cluster-supporting-line" title="Permalink"></a></h5><p>The final cluster points, obtained from their projections on the cluster-supporting line, are given by the <span>$p_\text{final}()$</span> function according to:</p><p class="math-container">\[\mathbf{P}_i^\text{final} = p_\text{final}(\mathbf{P}_i^\text{proj}, f_\sigma, \ell_i, \hat{\mathbf{d}}_i, \mathbf{c}_i)\]</p><p>where <span>$\mathbf{P}_i^\text{final}$</span> is a <span>$p_i \times n$</span> matrix containing the coordinates of the generated points, <span>$\mathbf{P}_i^\text{proj}$</span> is the <span>$p_i \times n$</span> matrix of projection coordinates (determined in the previous step), and <span>$f_\sigma$</span> is the lateral dispersion parameter. In turn, <span>$\ell_i$</span>, <span>$\hat{\mathbf{d}}_i$</span> and <span>$\mathbf{c}_i$</span> are the length, direction and center of the cluster-supporting line.</p><p>The <span>$p_\text{final}()$</span> function is an optional parameter, allowing users to customize its behavior. <code>CluGen.jl</code> provides two concrete implementations out of the box, specified in Julia by passing <code>&quot;n-1&quot;</code> or <code>&quot;n&quot;</code> to <a href="../reference/#CluGen.clugen"><code>clugen()</code></a>&#39;s <code>point_dist_fn</code> parameter. These work as follows:</p><ul><li><code>&quot;n-1&quot;</code> (default) - Points are placed on a hyperplane orthogonal to the cluster-supporting line and intersecting the point&#39;s projection. This is done by obtaining <span>$p_i$</span> random unit vectors orthogonal to <span>$\hat{\mathbf{d}}_i$</span>, and determining their magnitude using the normal distribution (<span>$\mu=0$</span>, <span>$\sigma=f_\sigma$</span>). These vectors are then added to the respective projections on the cluster-supporting line, yielding the final cluster points. This behavior is implemented in the <a href="../reference/#CluGen.clupoints_n_1"><code>CluGen.clupoints_n_1()</code></a> function.</li><li><code>&quot;n&quot;</code> - Points are placed around their respective projections. This is done by obtaining <span>$p_i$</span> random unit vectors, and determining their magnitude using the normal distribution (<span>$\mu=0$</span>, <span>$\sigma=f_\sigma$</span>). These vectors are then added to the respective projections on the cluster-supporting line, yielding the final cluster points. This behavior is implemented in the <a href="../reference/#CluGen.clupoints_n"><code>CluGen.clupoints_n()</code></a> function.</li></ul><p>Figure 7 highlights the differences between these two approaches in 2D, where a hyperplane is simply a line.</p><p><img src="../point_dist_ex.svg" alt/> <strong>Figure 7</strong> - Example of how the final cluster points are obtained in 2D when using the built-in implementations for <span>$p_\text{final}()$</span>.</p><p>In general, points can be placed using a <code>&quot;n-1&quot;</code> or <code>&quot;n&quot;</code> strategy using any distribution. Figure 8 displays several examples for various implementations of <span>$p_\text{final}()$</span>, either based on <code>&quot;n-1&quot;</code> or <code>&quot;n&quot;</code> strategy, using different distributions. Figures 8a and 8b show the built-in <code>&quot;n-1&quot;</code> and <code>&quot;n&quot;</code> strategies making use of the normal distribution. Figures 8c-8f highlight some possibilities with custom user functions. Figure 8c shows the effect of using the exponential distribution in a <code>&quot;n-1&quot;</code> strategy, while Figure 8d displays the result of using a bimodal distribution with the same strategy. A more complex distribution, producing &quot;hollow&quot; clusters with a <code>&quot;n&quot;</code> strategy, is employed in Figures 8e and 8f, with the latter also having the <span>$p_\text{proj}()$</span> function set to <code>&quot;unif&quot;</code>. The remaining parameters (for all subfigures) are set as in Figure 1, except for <span>$p$</span>, which is set to 5000.</p><p><img src="../point_dist_fn.svg" alt/> <strong>Figure 8</strong> - Examples of various implementations of <span>$p_\text{final}()$</span>. Figures a and b shown the effect of the built-in implementations, while Figures c-f display results obtained using custom user functions.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 7 February 2023 19:14">Tuesday 7 February 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
