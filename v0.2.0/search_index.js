var documenterSearchIndex = {"docs":
[{"location":"dev/#Development","page":"Development","title":"Development","text":"","category":"section"},{"location":"dev/#Setup-package-for-development","page":"Development","title":"Setup package for development","text":"","category":"section"},{"location":"dev/","page":"Development","title":"Development","text":"pkg> dev https://github.com/clugen/CluGen.jl.git","category":"page"},{"location":"dev/#Run-tests","page":"Development","title":"Run tests","text":"","category":"section"},{"location":"dev/","page":"Development","title":"Development","text":"pkg> test CluGen","category":"page"},{"location":"dev/","page":"Development","title":"Development","text":"warning: Warning\nAt the moment, due to PRNG differences between Julia versions, doctests will only run in Julia 1.6 LTS.","category":"page"},{"location":"dev/#Build-the-documentation","page":"Development","title":"Build the documentation","text":"","category":"section"},{"location":"dev/","page":"Development","title":"Development","text":"note: Note\nBuilding the documentation requires at least Julia 1.6.","category":"page"},{"location":"dev/","page":"Development","title":"Development","text":"The following instructions assume we're on the CluGen folder (typically located in ~/.julia/dev/).","category":"page"},{"location":"dev/","page":"Development","title":"Development","text":"To build the documentation, enter the Julia REPL. Then activate the docs project and install its dependencies:","category":"page"},{"location":"dev/","page":"Development","title":"Development","text":"pkg> activate docs\n\npkg> instantiate","category":"page"},{"location":"dev/","page":"Development","title":"Development","text":"The documentation can now be generated from the Julia REPL:","category":"page"},{"location":"dev/","page":"Development","title":"Development","text":"julia> include(\"docs/make.jl\")","category":"page"},{"location":"dev/","page":"Development","title":"Development","text":"Or from the system terminal:","category":"page"},{"location":"dev/","page":"Development","title":"Development","text":"$ julia --project=docs --color=yes ./docs/make.jl","category":"page"},{"location":"dev/","page":"Development","title":"Development","text":"The generated documentation can be served locally with, e.g., Python's built-in HTTP server:","category":"page"},{"location":"dev/","page":"Development","title":"Development","text":"$ python -m http.server 9000 -d ./docs/build","category":"page"},{"location":"dev/","page":"Development","title":"Development","text":"Point your browser to http://localhost:9000/ to read the generated documentation.","category":"page"},{"location":"dev/#Useful-packages-for-helping-development","page":"Development","title":"Useful packages for helping development","text":"","category":"section"},{"location":"dev/","page":"Development","title":"Development","text":"While developing CluGen, the Revise package is useful to avoid restarting the Julia session each time CluGen's code is edited. Install it with:","category":"page"},{"location":"dev/","page":"Development","title":"Development","text":"pkg> add Revise","category":"page"},{"location":"dev/","page":"Development","title":"Development","text":"Then load it before CluGen, e.g.:","category":"page"},{"location":"dev/","page":"Development","title":"Development","text":"julia> using Revise, CluGen","category":"page"},{"location":"dev/#Code-style","page":"Development","title":"Code style","text":"","category":"section"},{"location":"dev/","page":"Development","title":"Development","text":"To contribute to CluGen, follow the Blue Style.","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"This section describes the theoretical framework of the clugen algorithm, starting with a general Overview, then moving on to a Detailed description.","category":"page"},{"location":"theory/#Overview","page":"Theory","title":"Overview","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Clugen is an algorithm for generating multidimensional clusters. Each cluster is supported by a line segment, the position, orientation and length of which guide where the respective points are placed. For brevity, line segments will be referred to as lines.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Given an n-dimensional direction vector mathbfd (and a number of additional parameters, which will be discussed shortly), the clugen algorithm works as follows (^* means the algorithm step is stochastic):","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Normalize mathbfd.\n^*Determine cluster sizes.\n^*Determine cluster centers.\n^*Determine lengths of cluster-supporting lines.\n^*Determine angles between mathbfd and cluster-supporting lines.\nFor each cluster:\n^*Determine direction of the cluster-supporting line.\n^*Determine distance of point projections from the center of the cluster-supporting line.\nDetermine coordinates of point projections on the cluster-supporting line.\n^*Determine points from their projections on the cluster-supporting line.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Figure 1 provides a stylized overview of the algorithm's steps.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ENV[\"GKSwstype\"] = \"100\"\nusing CluGen, LinearAlgebra, Plots, StableRNGs, Main.CluGenExtras\n\n# Create clusters\nd = [1, 1]\nnclu = 4\nr = clugen(2, nclu, 200, d, pi/16, [10, 10], 10, 1.5, 1; rng = StableRNG(9999))\nplt, _ = plot_story_2d(d, r)\n\nsavefig(plt, \"algorithm.svg\")\n\nnothing","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: ) Figure 1 - Stylized overview of the clugen algorithm. Background tiles are 10 units wide and tall, when applicable.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The example in Figure 1 was generated with the following parameters, the exact meaning of each will be discussed shortly:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Parameter values Description\nn=2 Number of dimensions.\nc=4 Number of clusters.\np=200 Total number of points.\nmathbfd=beginbmatrix1  1endbmatrix^T Average direction.\ntheta_sigma=pi16approx1125^circ Angle dispersion.\nmathbfs=beginbmatrix10  10endbmatrix^T Average cluster separation.\nl=10 Average line length.\nl_sigma=15 Line length dispersion.\nf_sigma=1 Cluster lateral dispersion.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Additionally, all optional parameters (not listed above) were left to their default values. These will also be discussed next. This example can be reproduced and plotted with the following instructions (the StableRNGs package is used to keep the example reproducible between Julia versions):","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"julia> using CluGen, Plots, StableRNGs\n\njulia> r = clugen(2, 4, 200, [1, 1], pi/16, [10, 10], 10, 1.5, 1; rng = StableRNG(9999));\n\njulia> plot(r.points[:,1], r.points[:,2], seriestype = :scatter, group=r.clusters)","category":"page"},{"location":"theory/#Detailed-description","page":"Theory","title":"Detailed description","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"In this section we provide a detailed description of the algorithm and its parameters. We start by listing and describing all parameters (mandatory and optional), and then analyze the algorithm in detail, highlighting how each parameter influences the end result.","category":"page"},{"location":"theory/#Algorithm-parameters","page":"Theory","title":"Algorithm parameters","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The clugen algorithm (and consequently, the clugen() function) has mandatory and optional parameters, listed and described in the tables below. The optional parameters are set to sensible defaults, and in many situations may be left unchanged. Nonetheless, these allow all of the algorithm's steps to be fully customized by the user.","category":"page"},{"location":"theory/#Mandatory-parameters","page":"Theory","title":"Mandatory parameters","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Symbol Parameter Description\nn num_dims Number of dimensions.\nc num_clusters Number of clusters.\np num_points Total number of points to generate.\nmathbfd direction Average direction of cluster-supporting lines (n times 1).\ntheta_sigma angle_disp Angle dispersion of cluster-supporting lines (radians).\nmathbfs cluster_sep Average cluster separation in each dimension (n times 1).\nl llength Average length of cluster-supporting lines.\nl_sigma llength_disp Length dispersion of cluster-supporting lines.\nf_sigma lateral_disp Cluster lateral dispersion, i.e., dispersion of points from their projection on the cluster-supporting line.","category":"page"},{"location":"theory/#Optional-parameters","page":"Theory","title":"Optional parameters","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Symbol Parameter Default value Description\nphi allow_empty false Allow empty clusters?\nmathbfo cluster_offset zeros(num_dims) Offset to add to all cluster centers (n times 1).\np_textproj() proj_dist_fn \"norm\" Distribution of point projections along cluster-supporting lines.\np_textfinal() point_dist_fn \"n-1\" Distribution of final points from their projections.\nc_s() clusizes_fn CluGen.clusizes() Distribution of cluster sizes.\nc_c() clucenters_fn CluGen.clucenters() Distribution of cluster centers.\nl() llengths_fn CluGen.llengths() Distribution of line lengths.\ntheta_Delta() angle_deltas_fn CluGen.angle_deltas() Distribution of line angle deltas (w.r.t. mathbfd).","category":"page"},{"location":"theory/#The-algorithm-in-detail","page":"Theory","title":"The algorithm in detail","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The clugen algorithm is presented in Overview. In this section we will analyze each of the algorithms steps in detail.","category":"page"},{"location":"theory/#.-Normalize-\\mathbf{d}","page":"Theory","title":"1. Normalize mathbfd","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"This is a basic step, which consists of converting mathbfd to a unit vector:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"hatmathbfd = cfracmathbfdleftlVertmathbfdrightrVert","category":"page"},{"location":"theory/#.-Determine-cluster-sizes","page":"Theory","title":"2. Determine cluster sizes","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Cluster sizes are given by the c_s() function according to:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"mathbfc_s = c_s(c p phi)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where mathbfc_s is an c times 1 integer vector containing the final cluster sizes, c is the number of clusters, p is the total number of points, and phi is a boolean which determines whether empty clusters are acceptable.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The c_s() function is an optional parameter, allowing users to customize its behavior. By default, c_s() is implemented by the CluGen.clusizes() function, which behaves according to the following algorithm:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Determine the size p_i of each cluster i according to p_isimleftlfloormaxleft(mathcalN(fracpc (fracp3c)^2)0right)rightrceil, where lfloorrceil denotes the round to nearest integer function, and  mathcalN(musigma^2) represents the normal distribution with mean mu and variance sigma^2.\nAssure that the final cluster sizes add up to p by incrementing the smallest cluster size while sum_i=1^c p_ip or decrementing the largest cluster size while sum_i=1^c p_ip. This step is delegated to the CluGen.fix_num_points!() helper function.\nIf negphiwedge pge c then, for each empty cluster i (i.e., p_i=0), increment p_i and decrement p_j, where j denotes the largest cluster. This step is delegated to the CluGen.fix_empty!() helper function.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Figure 2 demonstrates possible cluster sizes with various definitions of c_s() for c=4 and p=5000. The default behavior, implemented in the CluGen.clusizes() function, is shown in Figure 2a, while Figures 2b-d present results obtained with custom user functions. Figure 2b displays cluster sizes obtained with the discrete uniform distribution over left1 2 ldots frac2pcright, corrected with CluGen.fix_num_points!(). In turn, Figure 2c highlights cluster sizes obtained with the Poisson distribution with lambda=fracpc, also corrected with CluGen.fix_num_points!(). The cluster sizes shown in Figure 2d were determined with the same distribution (Poisson, lambda=fracpc), but were not corrected. Thus, cluster sizes do not add up to p, highlighting the fact that this is not a requirement of the clugen algorithm, i.e., user-defined  c_s() implementations can consider p a hint rather than an obligation.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ENV[\"GKSwstype\"] = \"100\"\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras\n\npltbg = RGB(0.92, 0.92, 0.95) #\"whitesmoke\"\n\n# General cluster definitions\nd = [1, 1]\nnclu = 4\nnpts = 5000\nastd = pi/16\nclusep = [10, 10]\nlinelen = 10\nlinelen_std = 1.5\nlatstd = 1\n\n# Different clusizes_fn's to use\nclusz_names = (\"a) Normal (default).\", \"b) Uniform.\", \"c) Poisson.\", \"d) Poisson (no total points correction).\")\n\nclusz = Dict(\n   clusz_names[1] => CluGen.clusizes,\n   clusz_names[2] => (nclu, npts, aempty; rng = nothing) -> CluGen.fix_num_points!(rand(rng, DiscreteUniform(1, 2 * npts / nclu), nclu), npts), # Never empty since we're starting at 1\n   clusz_names[3] => (nclu, npts, aempty; rng = nothing) -> CluGen.fix_empty!(CluGen.fix_num_points!(rand(rng, Poisson(npts / nclu), nclu), npts), aempty),\n   clusz_names[4] => (nclu, npts, aempty; rng = nothing) -> CluGen.fix_empty!(rand(rng, Poisson(npts / nclu), nclu), aempty)\n)\n\n# Plots\np_all = []\ncluszs_all = Dict()\nmaxclu = 0\n\nrng = StableRNG(345)\n\nfor csz_name in clusz_names\n\n   cluszs_all[csz_name] = clusz[csz_name](nclu, npts, false; rng = rng)\n\n   if maximum(cluszs_all[csz_name]) > maxclu\n      global maxclu = maximum(cluszs_all[csz_name])\n   end\n\nend\n\nfor csz_name in clusz_names\n\n   p = plot(title=csz_name, titlefontsize=10, titlelocation=:left, legend=false,\n      showaxis=false, foreground_color_axis=ARGB(1,1,1,0), grid=false, ticks=[],\n      aspectratio=1, background_color_inside=pltbg)\n\n   plot_clusizes!(p, cluszs_all[csz_name]; maxsize = round(Integer, maxclu * 1.1))\n\n   push!(p_all, p)\n\n   while length(p_all) in (2, 5)\n      push!(p_all, plot(showaxis=false,grid=false,ticks=[],aspectratio=1))\n   end\nend\n\nplt = plot(p_all..., layout = (2, 3), size=(1200,800))\n\nsavefig(plt, \"clusizes.svg\")\n\nnothing","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: ) Figure 2 - Possible cluster sizes with various definitions of c_s() for c=4 and p=5000.","category":"page"},{"location":"theory/#.-Determine-cluster-centers","page":"Theory","title":"3. Determine cluster centers","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Cluster sizes are given by the c_c() function according to:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"mathbfC = c_c(c mathbfs mathbfo)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where mathbfC is an c times n matrix containing the final cluster centers, c is the number of clusters, mathbfs is the average cluster separation (n times 1 vector), and mathbfo is an n times 1 vector of cluster offsets.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The c_c() function is an optional parameter, allowing users to customize its behavior. By default, c_c() is implemented by the CluGen.clucenters() function, which determines the cluster centers according to:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"mathbfC=cmathbfU cdot operatornamediag(mathbfs) + mathbf1mathbfo^T","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where mathbfU is an c times n matrix of random values drawn from the uniform distribution between -0.5 and 0.5, and mathbf1 is an c times 1 vector with all entries equal to 1.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Figure 3 shows scatters plots of the results generated by clugen for two different implementations of the c_c() function, namely using the uniform the distribution (the default, implemented by the CluGen.clucenters() function, Figure 3a), and direct specification of cluster centers (Figure 3b).","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ENV[\"GKSwstype\"] = \"100\"\nusing CluGen, Distributions, Plots, StableRNGs\n\npltbg = RGB(0.92, 0.92, 0.95) #\"whitesmoke\"\n\n# General cluster definitions\nd = [1, 1]\nnclu = 4\nnpts = 5000\nastd = pi/16\nclusep = [10, 10]\nlinelen = 10\nlinelen_std = 1.5\nlatstd = 1\n\n# Different clucenter_fn's to use\ncluctr_names = (\"a) Uniform (default).\", \"b) Hand-picked.\")\n\ncluctr = Dict(\n   cluctr_names[1] => CluGen.clucenters,\n   cluctr_names[2] => (nclu, clusep, cluoff; rng = nothing) -> rand(rng, nclu, length(clusep)) .* 0 + [-20 -20; -20 20; 20 20; 20 -20]\n)\n\n# Results and plots\nr_all = []\np_all = []\n\nfor cluc_name in cluctr_names\n   r = clugen(2, nclu, npts, d, astd, clusep, linelen, linelen_std, latstd; clucenters_fn = cluctr[cluc_name], rng = StableRNG(9999))\n   push!(r_all, r)\n   p = plot(r.points[:,1], r.points[:,2], seriestype = :scatter,\n      group=r.clusters, xlim=(-35,35), ylim=(-35,35), legend=false,\n      markersize=1.5, markerstrokewidth=0.1, formatter=x->\"\", framestyle=:grid,\n      foreground_color_grid=:white, gridalpha=1, background_color_inside=pltbg,\n      gridlinewidth=2, aspectratio=1, title=cluc_name, titlefontsize=10,\n      titlelocation=:left)\n   push!(p_all, p)\nend\n\npush!(p_all, plot(showaxis=false,grid=false,ticks=[],aspectratio=1))\n\nplt = plot(p_all..., layout = (1, 3), size=(1200, 400))\n\nsavefig(plt, \"clucenters.svg\")\n\nnothing","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: ) Figure 3 - The output of clugen for two different implementations of the c_c() function for finding cluster centers: a) the default, using the uniform distribution; b) hand-picked centers. All parameters are the same as in Figure 1, except for p, which is set to 5000.","category":"page"},{"location":"theory/#.-Determine-lengths-of-cluster-supporting-lines","page":"Theory","title":"4. Determine lengths of cluster-supporting lines","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The lengths of the cluster-supporting lines are given by the l() function according to:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"pmbell = l(c l l_sigma)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where pmbell is an c times 1 vector containing the final lengths of the cluster-supporting lines, c is the number of clusters, l is the average length, and l_sigma is the length dispersion.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The l() function is an optional parameter, allowing users to customize its behavior. By default, l() is implemented by the CluGen.llengths() function, which determines the ell_i length of each cluster-supporting line i according to:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ell_isimleftmathcalN(ll_sigma^2)right","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where leftmathcalN(musigma^2)right represents the folded normal distribution with mean mu and variance sigma^2.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Figure 4 shows cluster-supporting line lengths obtained with different implementations of l().","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ENV[\"GKSwstype\"] = \"100\"\nusing CluGen, Distributions, Plots, StableRNGs\n\npltbg = RGB(0.92, 0.92, 0.95) #\"whitesmoke\"\n\n# General cluster definitions\nd = [1, 1]\nnclu = 4\nnpts = 5000\nastd = 0 # To better see line lengths\nclusep = [10, 10]\nlinelen = 10\nlinelen_std = 1.5\nlatstd = 0 # To better see line lengths\n\n# Different llengths_fn's to use\nll_names = (\"a) Folded normal (default).\", \"b) Poisson.\", \"c) Uniform.\", \"d) Hand-picked.\")\n\nll = Dict(\n   ll_names[1] => CluGen.llengths,\n   ll_names[2] => (nclu, ll, llstd; rng = nothing) -> rand(rng, Poisson(ll), nclu),\n   ll_names[3] => (nclu, ll, llstd; rng = nothing) -> rand(rng, Uniform(0, ll * 2), nclu),\n   ll_names[4] => (nclu, ll, llstd; rng = nothing) -> rand(rng, nclu) .* 0 + [2, 8, 16, 32]\n)\n\n# Results and plots\nr_all = []\np_all = []\n\nfor ll_name in ll_names\n   r = clugen(2, nclu, npts, d, astd, clusep, linelen, linelen_std, latstd; llengths_fn = ll[ll_name], proj_dist_fn=\"unif\", rng = StableRNG(9999))\n   push!(r_all, r)\n   p = plot(r.points[:,1], r.points[:,2], seriestype = :scatter,\n      group=r.clusters, xlim=(-35,35), ylim=(-35,35), legend=false,\n      markersize=1.5, markerstrokewidth=0.1, formatter=x->\"\", framestyle=:grid,\n      foreground_color_grid=:white, gridalpha=1, background_color_inside=pltbg,\n      gridlinewidth=2, aspectratio=1, title=ll_name, titlefontsize=10,\n      titlelocation=:left)\n   push!(p_all, p)\n\n   while length(p_all) in (2, 5)\n      push!(p_all, plot(showaxis=false,grid=false,ticks=[],aspectratio=1))\n   end\n\nend\n\nplt = plot(p_all..., layout = (2, 3), size=(1200,800))\n\nsavefig(plt, \"llengths.svg\")\n\nnothing","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: ) Figure 4 - Line lengths for different implementations of l(): a) the default, using the folded normal distribution; b) using the Poisson distribution, with lambda=l; c) using the uniform distribution in the interval left0 2lright; and, d) hand-picked lengths, more specifically pmbell=beginbmatrix2  8  16  32endbmatrix^T. Cluster centers, as well as parameters l and l_sigma, are the same as for the example shown in Figure 1.","category":"page"},{"location":"theory/#.-Determine-angles-between-\\mathbf{d}-and-cluster-supporting-lines","page":"Theory","title":"5. Determine angles between mathbfd and cluster-supporting lines","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The angles between mathbfd and the cluster-supporting lines are given by the theta_Delta() function according to:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"mathbfTheta_Delta = theta_Delta(c theta_sigma)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where mathbfTheta_Delta is an c times 1 vector containing the final angle differences between mathbfd and the cluster-supporting lines, c is the number of clusters, and theta_sigma is the angle dispersion.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The theta_Delta() function is an optional parameter, allowing users to customize its behavior. By default, theta_Delta() is implemented by the CluGen.angle_deltas() function, which determines the theta_Delta i angle difference between mathbfd and the i-th  cluster-supporting line according to:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"theta_Delta isimmathcalWN_-pi2^pi2(0theta_sigma^2)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where mathcalWN_-pi2^pi2(musigma^2) represents the wrapped normal distribution with mean mu, variance sigma^2, and support in the left-pi2pi2right interval, and theta_sigma is the angle dispersion of the cluster-supporting lines.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Figure 5 shows the final direction of the cluster-supporting lines for two different implementations of theta_Delta().","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ENV[\"GKSwstype\"] = \"100\"\nusing CluGen, Distributions, Plots, StableRNGs\n\npltbg = RGB(0.92, 0.92, 0.95) #\"whitesmoke\"\n\n# General cluster definitions\nd = [1, 1]\nnclu = 4\nnpts = 5000\nastd = pi/16\nclusep = [10, 10]\nlinelen = 10\nlinelen_std = 0 # To better see line angles\nlatstd = 0 # To better see line angles\n\n# Different angle_deltas_fn's to use\nla_names = (\"a) Wrapped Normal (default).\", \"b) Hand-picked.\")\n\nla = Dict(\n   la_names[1] => CluGen.angle_deltas,\n   la_names[2] => (nclu, astd; rng = nothing) -> rand(rng, nclu) .* 0 + [0, pi/2, 0, pi/2]\n)\n\n# Results and plots\nr_all = []\np_all = []\n\nfor la_name in la_names\n   r = clugen(2, nclu, npts, d, astd, clusep, linelen, linelen_std, latstd; angle_deltas_fn = la[la_name], proj_dist_fn=\"unif\", rng = StableRNG(9999))\n   push!(r_all, r)\n   p = plot(r.points[:,1], r.points[:,2], seriestype = :scatter,\n      group=r.clusters, xlim=(-35,35), ylim=(-35,35), legend=false,\n      markersize=1.5, markerstrokewidth=0.1, formatter=x->\"\", framestyle=:grid,\n      foreground_color_grid=:white, gridalpha=1, background_color_inside=pltbg,\n      gridlinewidth=2, aspectratio=1, title=la_name, titlefontsize=10,\n      titlelocation=:left)\n   push!(p_all, p)\nend\n\npush!(p_all, plot(showaxis=false,grid=false,ticks=[],aspectratio=1))\n\nplt = plot(p_all..., layout = (1, 3), size=(1200,400))\n\nsavefig(plt, \"angle_deltas.svg\")\n\nnothing","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: ) Figure 5 - Final directions of the cluster supporting-lines for different implementations of theta_Delta(): a) the default, where angle differences were obtained using the wrapped normal distribution; and, d) hand-picked angle differences, more specifically mathbfTheta_Delta=beginbmatrix0  fracpi2  0  fracpi2endbmatrix^T. Cluster centers, as well as the angle dispersion theta_sigma, are the same as for the example shown in Figure 1.","category":"page"},{"location":"theory/#.-For-each-cluster-i:","page":"Theory","title":"6. For each cluster i:","text":"","category":"section"},{"location":"theory/#.1.-Determine-direction-of-the-cluster-supporting-line","page":"Theory","title":"6.1. Determine direction of the cluster-supporting line","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"In order to obtain the hatmathbfd_i final direction of cluster i supporting line, the following algorithm is used:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"1. Find random vector mathbfr with each component taken from the uniform distribution between -0.5 and 0.5.\n2. Normalize mathbfr:\nhatmathbfr=cfracmathbfrleftlVertmathbfrrightrVert\n3. If theta_Delta i  pi2 or n=1, set hatmathbfd_i=hatmathbfr and terminate the algorithm.\n4. If hatmathbfr is parallel to hatmathbfd go to 1.\n5. Determine vector mathbfd_perp orthogonal to hatmathbfd using the first iteration of the Gram-Schmidt process:\nmathbfd_perp=hatmathbfr-cfrachatmathbfdcdothatmathbfrhatmathbfdcdothatmathbfdhatmathbfd\n6. Normalize mathbfd_perp:\nhatmathbfd_perp=cfracmathbfd_perpleftlVertmathbfd_perprightrVert\n7. Determine vector mathbfd_i at angle theta_Delta i with hatmathbfd:\nmathbfd_i=hatmathbfd+tan(theta_Delta i)hatmathbfd_perp\n8. Normalize mathbfd_i:\nhatmathbfd_i=cfracmathbfd_ileftlVertmathbfd_irightrVert","category":"page"},{"location":"theory/#.2.-Determine-distance-of-point-projections-from-the-center-of-the-cluster-supporting-line","page":"Theory","title":"6.2. Determine distance of point projections from the center of the cluster-supporting line","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The distance of point projections from the center of the cluster-supporting line is given by the p_textproj() function according to:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"mathbfw_i = p_textproj(ell_i p_i)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where mathbfw_i is an p_i times 1 vector containing the distance of each point projection to the center of the line, while ell_i and p_i are the line length and number of points in cluster i, respectively.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The p_textproj() function is an optional parameter, allowing users to customize its behavior. CluGen.jl provides two concrete implementations out of the box, specified in Julia by passing \"norm\" or \"unif\" to  clugen()'s proj_dist_fn parameter. These work as follows:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"\"norm\" (default) - Each element of mathbfw_i is derived from mathcalN(0 (fracell_i6)^2), i.e., from the normal distribution, centered on the cluster-supporting line center (mu=0) and with a standard deviation of sigma=fracell_i6, such that the length of the line segment encompasses approx 99.73% of the generated projections. Consequently, some projections may be placed outside the line's end points.\n\"unif\" - Each element of mathbfw_i is derived from mathcalU(-fracell_i2 fracell_i2), i.e., from the continuous uniform distribution in the interval left-fracell_i2 fracell_i2right. Thus, projections will be uniformly dispersed along the cluster-supporting line.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The impact of various implementations of p_textproj() is demonstrated in Figure 6. Figures 6a and 6b show the clusters generated with the \"norm\" and \"unif\" options, respectively, while Figures 6c and 6d highlight custom user functions implementing the Laplace and Rayleigh distributions, respectively. All parameters are set as in Figure 1, except for p_textproj() in the case of Figures 6b-6d, and p, which is set to 5000.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ENV[\"GKSwstype\"] = \"100\"\nusing CluGen, Distributions, Plots, StableRNGs\n\npltbg = RGB(0.92, 0.92, 0.95) #\"whitesmoke\"\n\n# General cluster definitions\nd = [1, 1]\nnclu = 4\nnpts = 5000\nastd = pi/16\nclusep = [10, 10]\nlinelen = 10\nlinelen_std = 1.5\nlatstd = 1\n\n# Different proj_dist_fn's to use\npdist_names = (\"a) Normal (\\\"norm\\\" option, the default).\", \"b) Uniform (\\\"unif\\\" option).\", \"c) Laplace (user-defined function).\", \"d) Rayleigh (user-defined function).\")\n\npdists = Dict(\n   pdist_names[1] => \"norm\",\n   pdist_names[2] => \"unif\",\n   pdist_names[3] => (len, n, rg) -> rand(rg, Laplace(0, len / 6), n),\n   pdist_names[4] => (len, n, rg) -> rand(rg, Rayleigh(len / 3), n) .- len / 2\n)\n\n# Results and plots\nr_all = []\np_all = []\n\nfor pd_name in pdist_names\n   r = clugen(2, nclu, npts, d, astd, clusep, linelen, linelen_std, latstd; proj_dist_fn=pdists[pd_name], rng = StableRNG(9999))\n   push!(r_all, r)\n   p = plot(r.points[:,1], r.points[:,2], seriestype = :scatter,\n      group=r.clusters, xlim=(-35,35), ylim=(-35,35), legend=false,\n      markersize=1.5, markerstrokewidth=0.1, formatter=x->\"\", framestyle=:grid,\n      foreground_color_grid=:white, gridalpha=1, background_color_inside=pltbg,\n      gridlinewidth=2, aspectratio=1, title=pd_name, titlefontsize=10,\n      titlelocation=:left)\n   push!(p_all, p)\n\n   while length(p_all) in (2, 5)\n      push!(p_all, plot(showaxis=false,grid=false,ticks=[],aspectratio=1))\n   end\n\nend\n\nplt = plot(p_all..., layout = (2, 3), size=(1200,800))\n\nsavefig(plt, \"proj_dist_fn.svg\")\n\nnothing","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: ) Figure 6 - Clusters generated for various implementations of p_textproj(): a) the default, where line center distances are drawn for the normal distribution, specified using the in-built \"norm\" option; b) in which center distances are derived from the uniform distribution, via the in-built \"unif\" option; c) where line center distances are obtained from a custom user function implementing the Laplace distribution; and, d) in which a custom user function returns center distances drawn from the Rayleigh distribution. All parameters are set as in Figure 1, except for p_textproj() in the case of Figures 6b-6d, and p, which is set to 5000.","category":"page"},{"location":"theory/#.3.-Determine-coordinates-of-point-projections-on-the-cluster-supporting-line","page":"Theory","title":"6.3. Determine coordinates of point projections on the cluster-supporting line","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"This is a deterministic step performed by the points_on_line() function using the vector formulation of the line equation, as follows:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"mathbfP_i^textproj=mathbf1mathbfc_i^T + mathbfw_ihatmathbfd_i^T","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where mathbfP_i^textproj is the p_i times n matrix of point projection coordinates on the line, mathbf1 is an p_i times 1 vector with all entries equal to 1, mathbfc_i are the coordinates of the line center (n times 1 vector), mathbfw_i is the distance of each point projection to the center of the line (p_i times 1 vector obtained in the previous step), and hatmathbfd_i is the direction of the cluster-supporting line for cluster i.","category":"page"},{"location":"theory/#.4.-Determine-points-from-their-projections-on-the-cluster-supporting-line","page":"Theory","title":"6.4. Determine points from their projections on the cluster-supporting line","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The final cluster points, obtained from their projections on the cluster-supporting line, are given by the p_textfinal() function according to:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"mathbfP_i^textfinal = p_textfinal(mathbfP_i^textproj f_sigma ell_i hatmathbfd_i mathbfc_i)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where mathbfP_i^textfinal is a p_i times n matrix containing the coordinates of the generated points, mathbfP_i^textproj is the p_i times n matrix of projection coordinates (determined in the previous step), and f_sigma is the lateral dispersion parameter. In turn, ell_i, hatmathbfd_i and mathbfc_i are the length, direction and center of the cluster-supporting line.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The p_textfinal() function is an optional parameter, allowing users to customize its behavior. CluGen.jl provides two concrete implementations out of the box, specified in Julia by passing \"n-1\" or \"n\" to clugen()'s point_dist_fn parameter. These work as follows:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"\"n-1\" (default) - Points are placed on a hyperplane orthogonal to the cluster-supporting line and intersecting the point's projection. This is done by obtaining p_i random unit vectors orthogonal to hatmathbfd_i, and determining their magnitude using the normal distribution (mu=0, sigma=f_sigma). These vectors are then added to the respective projections on the cluster-supporting line, yielding the final cluster points. This behavior is implemented in the CluGen.clupoints_n_1() function.\n\"n\" - Points are placed around their respective projections. This is done by obtaining p_i random unit vectors, and determining their magnitude using the normal distribution (mu=0, sigma=f_sigma). These vectors are then added to the respective projections on the cluster-supporting line, yielding the final cluster points. This behavior is implemented in the CluGen.clupoints_n() function.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Figure 7 highlights the differences between these two approaches in 2D, where a hyperplane is simply a line.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ENV[\"GKSwstype\"] = \"100\"\nusing CluGen, Distributions, Plots, Random, Main.CluGenExtras\n\nRandom.seed!(123)\np1 = plot_point_placement_2d(20*rand(100).-10, 20, [0,0], [1,1], 2, CluGen.clupoints_n_1)\nplot!(p1, title=\"a) Using the \\\"n-1\\\" option (the default).\", titlefontsize=10, titlelocation=:left)\np2 = plot_point_placement_2d(20*rand(100).-10, 20, [0,0], [1,1], 2, CluGen.clupoints_n)\nplot!(p2, title=\"b) Using the \\\"n\\\" option.\", titlefontsize=10, titlelocation=:left)\n\np3 = plot(showaxis = false, grid = false, ticks = [], aspectratio = 1)\n\nplt = plot(p1, p2, p3, layout=(1,3), size=(1200,400))\n\nsavefig(plt, \"point_dist_ex.svg\")\n\nnothing","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: ) Figure 7 - Example of how the final cluster points are obtained in 2D when using the built-in implementations for p_textfinal().","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ENV[\"GKSwstype\"] = \"100\"\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras\n\npltbg = RGB(0.92, 0.92, 0.95) #\"whitesmoke\"\n\n# General cluster definitions\nd = [1, 1]\nnclu = 4\nnpts = 5000\nastd = pi/16\nclusep = [10, 10]\nlinelen = 10\nlinelen_std = 1.5\nlatstd = 1\n\n# Different point_dist_fn's to use\npoffs_names = (\"a) Normal \\\"n-1\\\" (built-in, default).\", \"b) Normal \\\"n\\\" (built-in).\", \"c) Exponential \\\"n-1\\\".\", \"d) Bimodal \\\"n-1\\\".\", \"e) Hollow \\\"n\\\".\", \"f) Hollow \\\"n\\\" combined with \\\"unif\\\" projections.\")\n\ndist_exp = (npts, lstd, rg) -> lstd .* rand(rg, Exponential(2 / lstd), npts, 1)\ndist_bimod = (npts, lstd, rg) -> lstd .* rand(rg, (-1, 1), npts) + lstd / 3 .* randn(rg, npts, 1)\n\npoffs = Dict(\n   poffs_names[1] => (\"n-1\", \"norm\"),\n   poffs_names[2] => (\"n\", \"norm\"),\n   poffs_names[3] => ((projs, lat_std, len, clu_dir, clu_ctr; rng=nothing) -> CluGen.clupoints_n_1_template(projs, lat_std, clu_dir, dist_exp; rng=rng), \"norm\"),\n   poffs_names[4] => ((projs, lat_std, len, clu_dir, clu_ctr; rng=nothing) -> CluGen.clupoints_n_1_template(projs, lat_std, clu_dir, dist_bimod; rng=rng), \"norm\"),\n   poffs_names[5] => (clupoints_n_hollow, \"norm\"),\n   poffs_names[6] => (clupoints_n_hollow, \"unif\")\n)\n\n# Results and plots\nr_all = []\np_all = []\n\nfor po_name in poffs_names\n   r = clugen(2, nclu, npts, d, astd, clusep, linelen, linelen_std, latstd; point_dist_fn=poffs[po_name][1], proj_dist_fn=poffs[po_name][2], rng = StableRNG(9999))\n   push!(r_all, r)\n   p = plot(r.points[:,1], r.points[:,2], seriestype = :scatter,\n      group=r.clusters, xlim=(-35,35), ylim=(-35,35), legend=false,\n      markersize=1.5, markerstrokewidth=0.1, formatter=x->\"\", framestyle=:grid,\n      foreground_color_grid=:white, gridalpha=1, background_color_inside=pltbg,\n      gridlinewidth=2, aspectratio=1, title=po_name, titlefontsize=10,\n      titlelocation=:left)\n   push!(p_all, p)\nend\n\nplt = plot(p_all..., layout = (2, 3), size=(1200,800))\n\nsavefig(plt, \"point_dist_fn.svg\")\n\nnothing","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"In general, points can be placed using a \"n-1\" or \"n\" strategy using any distribution. Figure 8 displays several examples for various implementations of p_textfinal(), either based on \"n-1\" or \"n\" strategy, using different distributions. Figures 8a and 8b show the built-in \"n-1\" and \"n\" strategies making use of the normal distribution. Figures 8c-8f highlight some possibilities with custom user functions. Figure 8c shows the effect of using the exponential distribution in a \"n-1\" strategy, while Figure 8d displays the result of using a bimodal distribution with the same strategy. A more complex distribution, producing \"hollow\" clusters with a \"n\" strategy, is employed in Figures 8e and 8f, with the latter also having the p_textproj() function set to \"unif\". The remaining parameters (for all subfigures) are set as in Figure 1, except for p, which is set to 5000.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: ) Figure 8 - Examples of various implementations of p_textfinal(). Figures a and b shown the effect of the built-in implementations, while Figures c-f display results obtained using custom user functions.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This section contains a number of examples on how to use CluGen. Each example must be preceded with:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using CluGen, Distributions, Plots, StableRNGs","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The StableRNGs package is used in these examples to keep them reproducible between Julia versions. In practice it might be simpler to specify a seed with Random.seed!() and omit the PRNG altogether, or use a built-in PRNG such as the Mersenne Twister.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The plots of each example are generated with helper functions available here.","category":"page"},{"location":"examples/#D-examples","page":"Examples","title":"2D examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The 2D examples were plotted with the plot_examples_2d() helper function, available here. For plotting an example directly, e.g. for e001, run:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plot(e001.points[:, 1], e001.points[:, 2], seriestype = :scatter, group = e001.clusters)","category":"page"},{"location":"examples/#Manipulating-the-direction-of-cluster-supporting-lines","page":"Examples","title":"Manipulating the direction of cluster-supporting lines","text":"","category":"section"},{"location":"examples/#Using-the-direction-parameter","page":"Examples","title":"Using the direction parameter","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\ne001 = clugen(2, 4, 200, [1, 0], 0, [10, 10], 10, 1.5, 0.5; rng = StableRNG(1))\ne002 = clugen(2, 4, 200, [1, 1], 0, [10, 10], 10, 1.5, 0.5; rng = StableRNG(1))\ne003 = clugen(2, 4, 200, [0, 1], 0, [10, 10], 10, 1.5, 0.5; rng = StableRNG(1))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_2d(\n    e001, \"e001: direction = [1, 0]\",\n    e002, \"e002: direction = [1, 1]\",\n    e003, \"e003: direction = [0, 1]\")\n\nsavefig(plt, \"ex2d_01.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Changing-the-angle_disp-parameter-and-using-a-custom-angle_deltas_fn-function","page":"Examples","title":"Changing the angle_disp parameter and using a custom angle_deltas_fn function","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\n# Custom angle_deltas function: arbitrarily rotate some clusters by 90 degrees\nangdel_90_fn(nclu, astd; rng=nothing) = rand(rng, [0, pi / 2], nclu)\n\ne004 = clugen(2, 6, 500, [1, 0], 0, [10, 10], 10, 1.5, 0.5;\n    rng = StableRNG(1))\ne005 = clugen(2, 6, 500, [1, 0], pi / 8, [10, 10], 10, 1.5, 0.5;\n    rng = StableRNG(1))\ne006 = clugen(2, 6, 500, [1, 0], 0, [10, 10], 10, 1.5, 0.5;\n    angle_deltas_fn = angdel_90_fn, rng = StableRNG(1))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_2d(\n    e004, \"e004: angle_disp = 0\",\n    e005, \"e005: angle_disp = π/8\",\n    e006, \"e006: custom angle_deltas function\")\n\nsavefig(plt, \"ex2d_02.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Manipulating-the-length-of-cluster-supporting-lines","page":"Examples","title":"Manipulating the length of cluster-supporting lines","text":"","category":"section"},{"location":"examples/#Using-the-llength-parameter","page":"Examples","title":"Using the llength parameter","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\ne007 = clugen(2, 5, 800, [1, 0], pi / 10, [10, 10], 0, 0, 0.5;\n    point_dist_fn = \"n\", rng = StableRNG(2))\ne008 = clugen(2, 5, 800, [1, 0], pi / 10, [10, 10], 10, 0, 0.5;\n    point_dist_fn = \"n\", rng = StableRNG(2))\ne009 = clugen(2, 5, 800, [1, 0], pi / 10, [10, 10], 30, 0, 0.5;\n    point_dist_fn = \"n\", rng = StableRNG(2))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_2d(\n    e007, \"e007: llength = 0\",\n    e008, \"e008: llength = 10\",\n    e009, \"e009: llength = 30\")\n\nsavefig(plt, \"ex2d_03.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Changing-the-llength_disp-parameter-and-using-a-custom-llengths_fn-function","page":"Examples","title":"Changing the llength_disp parameter and using a custom llengths_fn function","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\n# Custom llengths function: line lengths grow for each new cluster\nllen_grow_fn(nclu, llen, llenstd; rng = nothing) =\n    llen * (collect(0:(nclu - 1)) + llenstd * randn(rng, nclu))\n\ne010 = clugen(2, 5, 800, [1, 0], pi / 10, [10, 10], 15,  0.0, 0.5;\n    point_dist_fn = \"n\", rng = StableRNG(2))\ne011 = clugen(2, 5, 800, [1, 0], pi / 10, [10, 10], 15, 10.0, 0.5;\n    point_dist_fn = \"n\", rng = StableRNG(2))\ne012 = clugen(2, 5, 800, [1, 0], pi / 10, [10, 10], 10,  0.1, 0.5;\n    llengths_fn = llen_grow_fn, point_dist_fn = \"n\", rng = StableRNG(2))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_2d(\n    e010, \"e010: llength_disp = 0.0\",\n    e011, \"e011: llength_disp = 5.0\",\n    e012, \"e012: custom llengths function\")\n\nsavefig(plt, \"ex2d_04.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Manipulating-relative-cluster-positions","page":"Examples","title":"Manipulating relative cluster positions","text":"","category":"section"},{"location":"examples/#Using-the-cluster_sep-parameter","page":"Examples","title":"Using the cluster_sep parameter","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\ne013 = clugen(2, 8, 1000, [1, 1], pi / 4, [10, 10], 10, 2, 2.5; rng = StableRNG(321))\ne014 = clugen(2, 8, 1000, [1, 1], pi / 4, [30, 10], 10, 2, 2.5; rng = StableRNG(321))\ne015 = clugen(2, 8, 1000, [1, 1], pi / 4, [10, 30], 10, 2, 2.5; rng = StableRNG(321))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_2d(\n    e013, \"e013: cluster_sep = [10, 10]\",\n    e014, \"e014: cluster_sep = [30, 10]\",\n    e015, \"e015: cluster_sep = [10, 30]\")\n\nsavefig(plt, \"ex2d_05.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Changing-the-cluster_offset-parameter-and-using-a-custom-clucenters_fn-function","page":"Examples","title":"Changing the cluster_offset parameter and using a custom clucenters_fn function","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\n# Custom clucenters function: places clusters in a diagonal\ncenters_diag_fn(nclu, csep, coff; rng=nothing) =\n    ones(nclu, length(csep)) .* (1:nclu) * maximum(csep) .+ coff'\n\ne016 = clugen(2, 8, 1000, [1, 1], pi / 4, [10, 10], 10, 2, 2.5;\n    rng = StableRNG(321))\ne017 = clugen(2, 8, 1000, [1, 1], pi / 4, [10, 10], 10, 2, 2.5;\n    cluster_offset = [20, -20], rng = StableRNG(321))\ne018 = clugen(2, 8, 1000, [1, 1], pi / 4, [10, 10], 10, 2, 2.5;\n    cluster_offset = [-50, -50], clucenters_fn = centers_diag_fn, rng = StableRNG(321))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_2d(\n    e016, \"e016: default\",\n    e017, \"e017: cluster_offset = [20, -20]\",\n    e018, \"e018: custom clucenters function\")\n\nsavefig(plt, \"ex2d_06.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Lateral-dispersion-and-placement-of-point-projections-on-the-line","page":"Examples","title":"Lateral dispersion and placement of point projections on the line","text":"","category":"section"},{"location":"examples/#Normal-projection-placement-(default):-proj_dist_fn-\"norm\"","page":"Examples","title":"Normal projection placement (default): proj_dist_fn = \"norm\"","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\ne019 = clugen(2, 4, 1000, [1, 0], pi / 2, [20, 20], 13, 2, 0.0; rng = StableRNG(456))\ne020 = clugen(2, 4, 1000, [1, 0], pi / 2, [20, 20], 13, 2, 1.0; rng = StableRNG(456))\ne021 = clugen(2, 4, 1000, [1, 0], pi / 2, [20, 20], 13, 2, 3.0; rng = StableRNG(456))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_2d(\n    e019, \"e019: lateral_disp = 0\",\n    e020, \"e020: lateral_disp = 1\",\n    e021, \"e021: lateral_disp = 3\")\n\nsavefig(plt, \"ex2d_07.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Uniform-projection-placement:-proj_dist_fn-\"unif\"","page":"Examples","title":"Uniform projection placement: proj_dist_fn = \"unif\"","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\ne022 = clugen(2, 4, 1000, [1, 0], pi / 2, [20, 20], 13, 2, 0.0;\n    proj_dist_fn = \"unif\", rng = StableRNG(456))\ne023 = clugen(2, 4, 1000, [1, 0], pi / 2, [20, 20], 13, 2, 1.0;\n    proj_dist_fn = \"unif\", rng = StableRNG(456))\ne024 = clugen(2, 4, 1000, [1, 0], pi / 2, [20, 20], 13, 2, 3.0;\n    proj_dist_fn = \"unif\", rng = StableRNG(456))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_2d(\n    e022, \"e022: lateral_disp = 0\",\n    e023, \"e023: lateral_disp = 1\",\n    e024, \"e024: lateral_disp = 3\")\n\nsavefig(plt, \"ex2d_08.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Custom-projection-placement-using-the-Laplace-distribution","page":"Examples","title":"Custom projection placement using the Laplace distribution","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\n# Custom proj_dist_fn: point projections placed using the Laplace distribution\nproj_laplace(len, n, rng) = rand(rng, Laplace(0, len / 6), n)\n\ne025 = clugen(2, 4, 1000, [1, 0], pi / 2, [20, 20], 13, 2, 0.0;\n    proj_dist_fn = proj_laplace, rng = StableRNG(456))\ne026 = clugen(2, 4, 1000, [1, 0], pi / 2, [20, 20], 13, 2, 1.0;\n    proj_dist_fn = proj_laplace, rng = StableRNG(456))\ne027 = clugen(2, 4, 1000, [1, 0], pi / 2, [20, 20], 13, 2, 3.0;\n    proj_dist_fn = proj_laplace, rng = StableRNG(456))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_2d(\n    e025, \"e025: lateral_disp = 0\",\n    e026, \"e026: lateral_disp = 1\",\n    e027, \"e027: lateral_disp = 3\")\n\nsavefig(plt, \"ex2d_09.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Controlling-final-point-positions-from-their-projections-on-the-cluster-supporting-line","page":"Examples","title":"Controlling final point positions from their projections on the cluster-supporting line","text":"","category":"section"},{"location":"examples/#Points-on-hyperplane-orthogonal-to-cluster-supporting-line-(default):-point_dist_fn-\"n-1\"","page":"Examples","title":"Points on hyperplane orthogonal to cluster-supporting line (default): point_dist_fn = \"n-1\"","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\n# Custom proj_dist_fn: point projections placed using the Laplace distribution\nproj_laplace(len, n, rng) = rand(rng, Laplace(0, len / 6), n)\n\ne028 = clugen(2, 5, 1500, [1, 0], pi / 3, [20, 20], 12, 3, 1.0;\n    rng = StableRNG(345))\ne029 = clugen(2, 5, 1500, [1, 0], pi / 3, [20, 20], 12, 3, 1.0;\n    proj_dist_fn = \"unif\", rng = StableRNG(345))\ne030 = clugen(2, 5, 1500, [1, 0], pi / 3, [20, 20], 12, 3, 1.0;\n    proj_dist_fn = proj_laplace, rng = StableRNG(345))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_2d(\n    e028, \"e028: proj_dist_fn=\\\"norm\\\" (default)\",\n    e029, \"e029: proj_dist_fn=\\\"unif\\\"\",\n    e030, \"e030: custom proj_dist_fn (Laplace)\")\n\nsavefig(plt, \"ex2d_10.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Points-around-projection-on-cluster-supporting-line:-point_dist_fn-\"n\"","page":"Examples","title":"Points around projection on cluster-supporting line: point_dist_fn = \"n\"","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\n# Custom proj_dist_fn: point projections placed using the Laplace distribution\nproj_laplace(len, n, rng) = rand(rng, Laplace(0, len / 6), n)\n\ne031 = clugen(2, 5, 1500, [1, 0], pi / 3, [20, 20], 12, 3, 1.0;\n    point_dist_fn = \"n\", rng = StableRNG(345))\ne032 = clugen(2, 5, 1500, [1, 0], pi / 3, [20, 20], 12, 3, 1.0;\n    point_dist_fn = \"n\", proj_dist_fn = \"unif\", rng = StableRNG(345))\ne033 = clugen(2, 5, 1500, [1, 0], pi / 3, [20, 20], 12, 3, 1.0;\n    point_dist_fn = \"n\", proj_dist_fn = proj_laplace, rng = StableRNG(345))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_2d(\n    e031, \"e031: proj_dist_fn=\\\"norm\\\" (default)\",\n    e032, \"e032: proj_dist_fn=\\\"unif\\\"\",\n    e033, \"e033: custom proj_dist_fn (Laplace)\")\n\nsavefig(plt, \"ex2d_11.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Custom-point-placement-using-the-exponential-distribution","page":"Examples","title":"Custom point placement using the exponential distribution","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\n# Custom point_dist_fn: final points placed using the Exponential distribution\nfunction clupoints_n_1_exp(projs, lat_std, len, clu_dir, clu_ctr; rng=nothing)\n    dist_exp(npts, lstd, rg) = lstd .* rand(rg, Exponential(2 / lstd), npts, 1)\n    return CluGen.clupoints_n_1_template(projs, lat_std, clu_dir, dist_exp; rng=rng)\nend\n\n# Custom proj_dist_fn: point projections placed using the Laplace distribution\nproj_laplace(len, n, rng) = rand(rng, Laplace(0, len / 6), n)\n\ne034 = clugen(2, 5, 1500, [1, 0], pi / 3, [20, 20], 12, 3, 1.0;\n    point_dist_fn = clupoints_n_1_exp, rng = StableRNG(345))\ne035 = clugen(2, 5, 1500, [1, 0], pi / 3, [20, 20], 12, 3, 1.0;\n    point_dist_fn = clupoints_n_1_exp, proj_dist_fn = \"unif\", rng = StableRNG(345))\ne036 = clugen(2, 5, 1500, [1, 0], pi / 3, [20, 20], 12, 3, 1.0;\n    point_dist_fn = clupoints_n_1_exp, proj_dist_fn = proj_laplace, rng = StableRNG(345))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_2d(\n    e034, \"e034: proj_dist_fn=\\\"norm\\\" (default)\",\n    e035, \"e035: proj_dist_fn=\\\"unif\\\"\",\n    e036, \"e036: custom proj_dist_fn (Laplace)\")\n\nsavefig(plt, \"ex2d_12.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Manipulating-cluster-sizes","page":"Examples","title":"Manipulating cluster sizes","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\n# Custom clusizes_fn (e038): cluster sizes determined via the uniform distribution,\n# no correction for total points\nclusizes_unif(nclu, npts, ae; rng = nothing) =\n    rand(rng, DiscreteUniform(1, 2 * npts / nclu), nclu)\n\n# Custom clusizes_fn (e039): clusters all have the same size, no correction for total points\nclusizes_equal(nclu, npts, ae; rng = nothing) = (npts ÷ nclu) .* ones(Integer, nclu)\n\n# Custom clucenters_fn (all): yields fixed positions for the clusters\ncenters_fixed(nclu, csep, coff; rng = nothing) =\n    [-csep[1] -csep[2]; csep[1] -csep[2]; -csep[1] csep[2]; csep[1] csep[2]]\n\ne037 = clugen(2, 4, 1500, [1, 1], pi, [20, 20], 0, 0, 5;\n    clucenters_fn = centers_fixed, point_dist_fn = \"n\",\n    rng = StableRNG(9))\ne038 = clugen(2, 4, 1500, [1, 1], pi, [20, 20], 0, 0, 5;\n    clucenters_fn = centers_fixed, clusizes_fn = clusizes_unif, point_dist_fn = \"n\",\n    rng = StableRNG(9))\ne039 = clugen(2, 4, 1500, [1, 1], pi, [20, 20], 0, 0, 5;\n    clucenters_fn = centers_fixed, clusizes_fn = clusizes_equal, point_dist_fn = \"n\",\n    rng = StableRNG(9))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_2d(\n    e037, \"e037: normal dist. (default)\",\n    e038, \"e038: unif. dist. (custom)\",\n    e039, \"e039: equal size (custom)\")\n\nsavefig(plt, \"ex2d_13.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#D-examples-2","page":"Examples","title":"3D examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The 3D examples were plotted with the plot_examples_3d() helper function available here. For plotting an example directly, e.g. for e040, run:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plot(e040.points[:, 1], e040.points[:, 2], e040.points[:, 3], seriestype = :scatter, group = e040.clusters)`.","category":"page"},{"location":"examples/#Manipulating-the-direction-of-cluster-supporting-lines-2","page":"Examples","title":"Manipulating the direction of cluster-supporting lines","text":"","category":"section"},{"location":"examples/#Using-the-direction-parameter-2","page":"Examples","title":"Using the direction parameter","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\ne040 = clugen(3, 4, 500, [1, 0, 0], 0, [10, 10, 10], 15, 1.5, 0.5; rng = StableRNG(1))\ne041 = clugen(3, 4, 500, [1, 1, 1], 0, [10, 10, 10], 15, 1.5, 0.5; rng = StableRNG(1))\ne042 = clugen(3, 4, 500, [0, 0, 1], 0, [10, 10, 10], 15, 1.5, 0.5; rng = StableRNG(1))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_3d(\n    e040, \"e040: direction = [1, 0, 0]\",\n    e041, \"e041: direction = [1, 1, 1]\",\n    e042, \"e042: direction = [0, 0, 1]\")\n\nsavefig(plt, \"ex3d_01.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Changing-the-angle_disp-parameter-and-using-a-custom-angle_deltas_fn-function-2","page":"Examples","title":"Changing the angle_disp parameter and using a custom angle_deltas_fn function","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\n# Custom angle_deltas function: arbitrarily rotate some clusters by 90 degrees\nangdel_90_fn(nclu, astd; rng=nothing) = rand(rng, [0, pi / 2], nclu)\n\ne043 = clugen(3, 6, 1000, [1, 0, 0], 0, [10, 10, 10], 15, 1.5, 0.5;\n    rng = StableRNG(2))\ne044 = clugen(3, 6, 1000, [1, 0, 0], pi / 8, [10, 10, 10], 15, 1.5, 0.5;\n    rng = StableRNG(2))\ne045 = clugen(3, 6, 1000, [1, 0, 0], 0, [10, 10, 10], 15, 1.5, 0.5;\n    angle_deltas_fn = angdel_90_fn, rng = StableRNG(2))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_3d(\n    e043, \"e043: angle_disp = 0\",\n    e044, \"e044: angle_disp = π / 8\",\n    e045, \"e045: custom angle_deltas function\")\n\nsavefig(plt, \"ex3d_02.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Specifying-a-main-direction-for-each-cluster-and-changing-angle_disp","page":"Examples","title":"Specifying a main direction for each cluster and changing angle_disp","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\n# Directions for each cluster\ndirs = [[0 0 1];[1 1 0];[-1 1 0];[1 0 0];[0 1 0]]\n\ne046 = clugen(3, 5, 1000, dirs, 0, zeros(3), 10, 0, 0.1; rng = StableRNG(77))\ne047 = clugen(3, 5, 1000, dirs, π/12, zeros(3), 10, 0, 0.1; rng = StableRNG(77))\ne048 = clugen(3, 5, 1000, dirs, π/4, zeros(3), 10, 0, 0.1; rng = StableRNG(77))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_3d(\n    e046, \"e046: angle_disp = 0\",\n    e047, \"e047: angle_disp = π / 12\",\n    e048, \"e048: angle_disp = π / 4\")\n\nsavefig(plt, \"ex3d_dirclu_angd.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Manipulating-the-length-of-cluster-supporting-lines-2","page":"Examples","title":"Manipulating the length of cluster-supporting lines","text":"","category":"section"},{"location":"examples/#Using-the-llength-parameter-2","page":"Examples","title":"Using the llength parameter","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\ne049 = clugen(3, 5, 800, [1, 0, 0], pi / 10, [10, 10, 10], 0, 0, 0.5;\n    point_dist_fn = \"n\", rng = StableRNG(2))\ne050 = clugen(3, 5, 800, [1, 0, 0], pi / 10, [10, 10, 10], 10, 0, 0.5;\n    point_dist_fn = \"n\", rng = StableRNG(2))\ne051 = clugen(3, 5, 800, [1, 0, 0], pi / 10, [10, 10, 10], 30, 0, 0.5;\n    point_dist_fn = \"n\", rng = StableRNG(2))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_3d(\n    e049, \"e049: llength = 0\",\n    e050, \"e050: llength = 10\",\n    e051, \"e051: llength = 30\")\n\nsavefig(plt, \"ex3d_03.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Changing-the-llength_disp-parameter-and-using-a-custom-llengths_fn-function-2","page":"Examples","title":"Changing the llength_disp parameter and using a custom llengths_fn function","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\n# Custom llengths function: line lengths tend to grow for each new cluster\nllen_grow_fn(nclu, llen, llenstd; rng = nothing) =\n    llen * (collect(0:(nclu - 1)) + llenstd * randn(rng, nclu))\n\ne052 = clugen(3, 5, 800, [1, 0, 0], pi / 10, [10, 10, 10], 15,  0.0, 0.5;\n    point_dist_fn = \"n\", rng = StableRNG(2))\ne053 = clugen(3, 5, 800, [1, 0, 0], pi / 10, [10, 10, 10], 15, 10.0, 0.5;\n    point_dist_fn = \"n\", rng = StableRNG(2))\ne054 = clugen(3, 5, 800, [1, 0, 0], pi / 10, [10, 10, 10], 10,  0.1, 0.5;\n    llengths_fn = llen_grow_fn, point_dist_fn = \"n\", rng = StableRNG(2))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_3d(\n    e052, \"e052: llength_disp = 0.0\",\n    e053, \"e053: llength_disp = 10.0\",\n    e054, \"e054: custom llengths function\")\n\nsavefig(plt, \"ex3d_04.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Manipulating-relative-cluster-positions-2","page":"Examples","title":"Manipulating relative cluster positions","text":"","category":"section"},{"location":"examples/#Using-the-cluster_sep-parameter-2","page":"Examples","title":"Using the cluster_sep parameter","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\ne055 = clugen(3, 8, 1000, [1, 1, 1], pi / 4, [30, 10, 10], 25, 4, 3; rng = StableRNG(321))\ne056 = clugen(3, 8, 1000, [1, 1, 1], pi / 4, [10, 30, 10], 25, 4, 3; rng = StableRNG(321))\ne057 = clugen(3, 8, 1000, [1, 1, 1], pi / 4, [10, 10, 30], 25, 4, 3; rng = StableRNG(321))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_3d(\n    e055, \"e055: cluster_sep = [30, 10, 10]\",\n    e056, \"e056: cluster_sep = [10, 30, 10]\",\n    e057, \"e057: cluster_sep = [10, 10, 30]\")\n\nsavefig(plt, \"ex3d_05.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Changing-the-cluster_offset-parameter-and-using-a-custom-clucenters_fn-function-2","page":"Examples","title":"Changing the cluster_offset parameter and using a custom clucenters_fn function","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\n# Custom clucenters function: places clusters in a diagonal\ncenters_diag_fn(nclu, csep, coff; rng=nothing) = ones(nclu, length(csep)) .* (1:nclu) * maximum(csep) .+ coff'\n\ne058 = clugen(3, 8, 1000, [1, 1, 1], pi / 4, [10, 10, 10], 12, 3, 2.5;\n    rng = StableRNG(321))\ne059 = clugen(3, 8, 1000, [1, 1, 1], pi / 4, [10, 10, 10], 12, 3, 2.5;\n    cluster_offset = [20, -20, 20], rng = StableRNG(321))\ne060 = clugen(3, 8, 1000, [1, 1, 1], pi / 4, [10, 10, 10], 12, 3, 2.5;\n    cluster_offset = [-50, -50, -50], clucenters_fn = centers_diag_fn, rng = StableRNG(321))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_3d(\n    e058, \"e058: default\",\n    e059, \"e059: cluster_offset = [20, -20, 20]\",\n    e060, \"e060: custom clucenters function\")\n\nsavefig(plt, \"ex3d_06.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Lateral-dispersion-and-placement-of-point-projections-on-the-line-2","page":"Examples","title":"Lateral dispersion and placement of point projections on the line","text":"","category":"section"},{"location":"examples/#Normal-projection-placement-(default):-proj_dist_fn-\"norm\"-2","page":"Examples","title":"Normal projection placement (default): proj_dist_fn = \"norm\"","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\ne061 = clugen(3, 4, 1000, [1, 0, 0], pi / 2, [20, 20, 20], 13, 2, 0.0; rng = StableRNG(456))\ne062 = clugen(3, 4, 1000, [1, 0, 0], pi / 2, [20, 20, 20], 13, 2, 1.0; rng = StableRNG(456))\ne063 = clugen(3, 4, 1000, [1, 0, 0], pi / 2, [20, 20, 20], 13, 2, 3.0; rng = StableRNG(456))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_3d(\n    e061, \"e061: lateral_disp = 0\",\n    e062, \"e062: lateral_disp = 1\",\n    e063, \"e063: lateral_disp = 3\")\n\nsavefig(plt, \"ex3d_07.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Uniform-projection-placement:-proj_dist_fn-\"unif\"-2","page":"Examples","title":"Uniform projection placement: proj_dist_fn = \"unif\"","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\ne064 = clugen(3, 4, 1000, [1, 0, 0], pi / 2, [20, 20, 20], 13, 2, 0.0;\n    proj_dist_fn = \"unif\", rng = StableRNG(456))\ne065 = clugen(3, 4, 1000, [1, 0, 0], pi / 2, [20, 20, 20], 13, 2, 1.0;\n    proj_dist_fn = \"unif\", rng = StableRNG(456))\ne066 = clugen(3, 4, 1000, [1, 0, 0], pi / 2, [20, 20, 20], 13, 2, 3.0;\n    proj_dist_fn = \"unif\", rng = StableRNG(456))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_3d(\n    e064, \"e064: lateral_disp = 0\",\n    e065, \"e065: lateral_disp = 1\",\n    e066, \"e066: lateral_disp = 3\")\n\nsavefig(plt, \"ex3d_08.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Custom-projection-placement-using-the-Laplace-distribution-2","page":"Examples","title":"Custom projection placement using the Laplace distribution","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\n# Custom proj_dist_fn: point projections placed using the Laplace distribution\nproj_laplace(len, n, rng) = rand(rng, Laplace(0, len / 6), n)\n\ne067 = clugen(3, 4, 1000, [1, 0, 0], pi / 2, [20, 20, 20], 13, 2, 0.0;\n    proj_dist_fn = proj_laplace, rng = StableRNG(456))\ne068 = clugen(3, 4, 1000, [1, 0, 0], pi / 2, [20, 20, 20], 13, 2, 1.0;\n    proj_dist_fn = proj_laplace, rng = StableRNG(456))\ne069 = clugen(3, 4, 1000, [1, 0, 0], pi / 2, [20, 20, 20], 13, 2, 3.0;\n    proj_dist_fn = proj_laplace, rng = StableRNG(456))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_3d(\n    e067, \"e067: lateral_disp = 0\",\n    e068, \"e068: lateral_disp = 1\",\n    e069, \"e069: lateral_disp = 3\")\n\nsavefig(plt, \"ex3d_09.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Controlling-final-point-positions-from-their-projections-on-the-cluster-supporting-line-2","page":"Examples","title":"Controlling final point positions from their projections on the cluster-supporting line","text":"","category":"section"},{"location":"examples/#Points-on-hyperplane-orthogonal-to-cluster-supporting-line-(default):-point_dist_fn-\"n-1\"-2","page":"Examples","title":"Points on hyperplane orthogonal to cluster-supporting line (default): point_dist_fn = \"n-1\"","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\n# Custom proj_dist_fn: point projections placed using the Laplace distribution\nproj_laplace(len, n, rng) = rand(rng, Laplace(0, len / 6), n)\n\ne070 = clugen(3, 5, 1500, [1, 0, 0], pi / 3, [20, 20, 20], 22, 3, 2;\n    rng = StableRNG(34))\ne071 = clugen(3, 5, 1500, [1, 0, 0], pi / 3, [20, 20, 20], 22, 3, 2;\n    proj_dist_fn = \"unif\", rng = StableRNG(34))\ne072 = clugen(3, 5, 1500, [1, 0, 0], pi / 3, [20, 20, 20], 22, 3, 2;\n    proj_dist_fn = proj_laplace, rng = StableRNG(34))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_3d(\n    e070, \"e070: proj_dist_fn=\\\"norm\\\" (default)\",\n    e071, \"e071: proj_dist_fn=\\\"unif\\\"\",\n    e072, \"e072: custom proj_dist_fn (Laplace)\")\n\nsavefig(plt, \"ex3d_10.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Points-around-projection-on-cluster-supporting-line:-point_dist_fn-\"n\"-2","page":"Examples","title":"Points around projection on cluster-supporting line: point_dist_fn = \"n\"","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\n# Custom proj_dist_fn: point projections placed using the Laplace distribution\nproj_laplace(len, n, rng) = rand(rng, Laplace(0, len / 6), n)\n\ne073 = clugen(3, 5, 1500, [1, 0, 0], pi / 3, [20, 20, 20], 22, 3, 2;\n    point_dist_fn = \"n\", rng = StableRNG(34))\ne074 = clugen(3, 5, 1500, [1, 0, 0], pi / 3, [20, 20, 20], 22, 3, 2;\n    point_dist_fn = \"n\", proj_dist_fn = \"unif\", rng = StableRNG(34))\ne075 = clugen(3, 5, 1500, [1, 0, 0], pi / 3, [20, 20, 20], 22, 3, 2;\n    point_dist_fn = \"n\", proj_dist_fn = proj_laplace, rng = StableRNG(34))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_3d(\n    e073, \"e073: proj_dist_fn=\\\"norm\\\" (default)\",\n    e074, \"e074: proj_dist_fn=\\\"unif\\\"\",\n    e075, \"e075: custom proj_dist_fn (Laplace)\")\n\nsavefig(plt, \"ex3d_11.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Custom-point-placement-using-the-exponential-distribution-2","page":"Examples","title":"Custom point placement using the exponential distribution","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\n# Custom point_dist_fn: final points placed using the Exponential distribution\nfunction clupoints_n_1_exp(projs, lat_std, len, clu_dir, clu_ctr; rng=nothing)\n    dist_exp(npts, lstd, rg) = lstd .* rand(rg, Exponential(2 / lstd), npts, 1)\n    return CluGen.clupoints_n_1_template(projs, lat_std, clu_dir, dist_exp; rng=rng)\nend\n\n# Custom proj_dist_fn: point projections placed using the Laplace distribution\nproj_laplace(len, n, rng) = rand(rng, Laplace(0, len / 6), n)\n\ne076 = clugen(3, 5, 1500, [1, 0, 0], pi / 3, [20, 20, 20], 22, 3, 2;\n    point_dist_fn = clupoints_n_1_exp, rng = StableRNG(34))\ne077 = clugen(3, 5, 1500, [1, 0, 0], pi / 3, [20, 20, 20], 22, 3, 2;\n    point_dist_fn = clupoints_n_1_exp, proj_dist_fn = \"unif\", rng = StableRNG(34))\ne078 = clugen(3, 5, 1500, [1, 0, 0], pi / 3, [20, 20, 20], 22, 3, 2;\n    point_dist_fn = clupoints_n_1_exp, proj_dist_fn = proj_laplace, rng = StableRNG(34))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_3d(\n    e076, \"e076: proj_dist_fn=\\\"norm\\\" (default)\",\n    e077, \"e077: proj_dist_fn=\\\"unif\\\"\",\n    e078, \"e078: custom proj_dist_fn (Laplace)\")\n\nsavefig(plt, \"ex3d_12.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Manipulating-cluster-sizes-2","page":"Examples","title":"Manipulating cluster sizes","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\n# Custom clusizes_fn (e080): cluster sizes determined via the uniform distribution,\n# no correction for total points\nclusizes_unif(nclu, npts, ae; rng = nothing) =\n    rand(rng, DiscreteUniform(1, 2 * npts / nclu), nclu)\n\n# Custom clusizes_fn (e081): clusters all have the same size, no correction for total points\nclusizes_equal(nclu, npts, ae; rng = nothing) = (npts ÷ nclu) .* ones(Integer, nclu)\n\n# Custom clucenters_fn (all): yields fixed positions for the clusters\ncenters_fixed(nclu, csep, coff; rng=nothing) =\n    [ -csep[1] -csep[2] -csep[3]; csep[1] -csep[2] -csep[3];\n      -csep[1] csep[2] csep[3]; csep[1] csep[2] csep[3] ]\n\ne079 = clugen(3, 4, 1500, [1, 1, 1], pi, [20, 20, 20], 0, 0, 5;\n    clucenters_fn = centers_fixed, point_dist_fn = \"n\",\n    rng = StableRNG(9))\ne080 = clugen(3, 4, 1500, [1, 1, 1], pi, [20, 20, 20], 0, 0, 5;\n    clucenters_fn = centers_fixed, clusizes_fn = clusizes_unif, point_dist_fn = \"n\",\n    rng = StableRNG(9))\ne081 = clugen(3, 4, 1500, [1, 1, 1], pi, [20, 20, 20], 0, 0, 5;\n    clucenters_fn = centers_fixed, clusizes_fn = clusizes_equal, point_dist_fn = \"n\",\n    rng = StableRNG(9))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_3d(\n    e079, \"e079: normal dist. (default)\",\n    e080, \"e080: unif. dist. (custom)\",\n    e081, \"e081: equal size (custom)\")\n\nsavefig(plt, \"ex3d_13.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Examples-in-other-dimensions","page":"Examples","title":"Examples in other dimensions","text":"","category":"section"},{"location":"examples/#Basic-1D-example-with-density-plot","page":"Examples","title":"Basic 1D example with density plot","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following example was plotted with the plot_examples_1d() function available here.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Custom proj_dist_fn: point projections placed using the Laplace distribution\nproj_laplace(len, n, rng) = rand(rng, Laplace(0, len / 6), n)\n\ne082 = clugen(1, 3, 2000, [1], 0, [10], 6, 1.5, 0; rng = StableRNG(45))\ne083 = clugen(1, 3, 2000, [1], 0, [10], 6, 1.5, 0; proj_dist_fn = \"unif\", rng = StableRNG(45))\ne084 = clugen(1, 3, 2000, [1], 0, [10], 6, 1.5, 0; proj_dist_fn = proj_laplace, rng = StableRNG(45))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_1d(\n    e082, \"e082: proj_dist_fn=\\\"norm\\\" (default)\",\n    e083, \"e083: proj_dist_fn=\\\"unif\\\"\",\n    e084, \"e084: custom proj_dist_fn (Laplace)\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# There is a bug in StatsPlots which shows a warning in the generated output.\n# https://github.com/JuliaPlots/Plots.jl/issues/3746\n# https://discourse.julialang.org/t/warning-when-using-both-plots-and-statsplots/50118\n# We show the code above, which is not executed (thus shows no warning), and the\n# actual executed code is below. The warning shows in the CLI but doesn't appear\n# in the generated output. We can remove this trick when the bug is fixed.\n\nENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, StableRNGs, StatsPlots, Main.CluGenExtras # hide\n\n# Custom proj_dist_fn: point projections placed using the Laplace distribution\nproj_laplace(len, n, rng) = rand(rng, Laplace(0, len / 6), n)\n\ne082 = clugen(1, 3, 2000, [1], 0, [10], 6, 1.5, 0; rng = StableRNG(45))\ne083 = clugen(1, 3, 2000, [1], 0, [10], 6, 1.5, 0; proj_dist_fn = \"unif\", rng = StableRNG(45))\ne084 = clugen(1, 3, 2000, [1], 0, [10], 6, 1.5, 0; proj_dist_fn = proj_laplace, rng = StableRNG(45))\n\nplt = plot_examples_1d(\n    e082, \"e082: proj_dist_fn=\\\"norm\\\" (default)\",\n    e083, \"e083: proj_dist_fn=\\\"unif\\\"\",\n    e084, \"e084: custom proj_dist_fn (Laplace)\")\n\nsavefig(plt, \"ex1d_01.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#D-example-with-default-optional-arguments","page":"Examples","title":"5D example with default optional arguments","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following examples were plotted with the plot_examples_nd() function available here.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\nnd = 5\ne085 = clugen(nd, 6, 1500, [1, 1, 0.5, 0, 0], pi / 16, 30 .* ones(nd), 30, 4, 3;\n    rng = StableRNG(123))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_nd(e085, \"e085: 5D with optional parameters set to defaults\")\n\nsavefig(plt, \"ex5d_01.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#D-example-with-proj_dist_fn-\"unif\"-and-point_dist_fn-\"n\"","page":"Examples","title":"5D example with proj_dist_fn = \"unif\" and point_dist_fn = \"n\"","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing CluGen, Distributions, Plots, StableRNGs, Main.CluGenExtras # hide\n\nnd = 5\ne086 = clugen(nd, 6, 1500, [0.1, 0.3, 0.5, 0.3, 0.1], pi / 12, 30 .* ones(nd), 35, 5, 3.5;\n    proj_dist_fn = \"unif\", point_dist_fn = \"n\", rng = StableRNG(321))\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plt = plot_examples_nd(e086, \"e086: 5D with proj_dist_fn=\\\"unif\\\" and point_dist_fn=\\\"n\\\"\")\n\nsavefig(plt, \"ex5d_02.svg\") # hide\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Module\nCluGen\nMain function\nclugen\nCore functions\npoints_on_line\nrand_ortho_vector\nrand_unit_vector\nrand_vector_at_angle\nAlgorithm module functions\nCluGen.angle_deltas\nCluGen.clucenters\nCluGen.clupoints_n_1\nCluGen.clupoints_n\nCluGen.clusizes\nCluGen.llengths\nHelper functions\nangle_btw\nCluGen.clupoints_n_1_template\nCluGen.fix_empty!\nCluGen.fix_num_points!","category":"page"},{"location":"reference/#Module","page":"Reference","title":"Module","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CluGen","category":"page"},{"location":"reference/#CluGen","page":"Reference","title":"CluGen","text":"CluGen\n\nA Julia package for generating multidimensional clusters. Provides the clugen function for this purpose, as well as a number of auxiliary functions, used internally and modularly by clugen. Users can swap these auxiliary functions by their own customized versions, fine-tuning their cluster generation strategies, or even use them as the basis for their own generation algorithms.\n\n\n\n\n\n","category":"module"},{"location":"reference/#Main-function","page":"Reference","title":"Main function","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"clugen","category":"page"},{"location":"reference/#CluGen.clugen","page":"Reference","title":"CluGen.clugen","text":"clugen(\n    num_dims::Integer,\n    num_clusters::Integer,\n    num_points::Integer,\n    direction::AbstractArray{<:Real},\n    angle_disp::Real,\n    cluster_sep::AbstractArray{<:Real, 1},\n    llength::Real,\n    llength_disp::Real,\n    lateral_disp::Real;\n    # Keyword arguments\n    allow_empty::Bool = false,\n    cluster_offset::Union{AbstractArray{<:Real, 1}, Nothing} = nothing,\n    proj_dist_fn::Union{String, <:Function} = \"norm\",\n    point_dist_fn::Union{String, <:Function} = \"n-1\",\n    clusizes_fn::Function = GluGen.clusizes,\n    clucenters_fn::Function = GluGen.clucenters,\n    llengths_fn::Function = GluGen.llengths,\n    angle_deltas_fn::Function = GluGen.angle_deltas,\n    rng::AbstractRNG = Random.GLOBAL_RNG\n) -> NamedTuple{(\n        :points,      # Array{<:Real,2}\n        :clusters,    # Array{<:Integer,1}\n        :projections, # Array{<:Real,2}\n        :sizes,       # Array{<:Integer,1}\n        :centers,     # Array{<:Real,2}\n        :directions,  # Array{<:Real,2}\n        :lengths      # Array{<:Real,1}\n     )}\n\nGenerate multidimensional clusters.\n\nThis is the main function of the CluGen package, and possibly the only function most users will need.\n\nArguments (mandatory)\n\nnum_dims: Number of dimensions.\nnum_clusters: Number of clusters to generate.\nnum_points: Total number of points to generate.\ndirection: Average direction of the cluster-supporting lines. Can be given as the same vector for all clusters (num_dims x 1) or as a direction per cluster matrix (num_clusters x num_dims).\nangle_disp: Angle dispersion of cluster-supporting lines (radians).\ncluster_sep: Average cluster separation in each dimension (num_dims x 1).\nllength: Average length of cluster-supporting lines.\nllength_disp: Length dispersion of cluster-supporting lines.\nlateral_disp: Cluster lateral dispersion, i.e., dispersion of points from their projection on the cluster-supporting line.\n\nNote that the terms \"average\" and \"dispersion\" refer to measures of central tendency and statistical dispersion, respectively. Their exact meaning depends on the optional arguments, described next.\n\nArguments (optional)\n\nallow_empty: Allow empty clusters? false by default.\ncluster_offset: Offset to add to all cluster centers. If set to nothing (the default), the offset will be equal to zeros(num_dims).\nproj_dist_fn: Distribution of point projections along cluster-supporting lines, with three possible values:\n\"norm\" (default): Distribute point projections along lines using a normal distribution (μ=line center, σ=llength/6).\n\"unif\": Distribute points uniformly along the line.\nUser-defined function, which accepts two parameters, line length (float), number of points (integer) and a random number generator, and returns an array containing the distance of each point projection to the center of the line. For example, the \"norm\" option roughly corresponds to (len, n, rng) -> (1.0 / 6.0) * len .* randn(rng, n).\npoint_dist_fn: Controls how the final points are created from their projections on the cluster-supporting lines, with three possible values:\n\"n-1\" (default): Final points are placed on a hyperplane orthogonal to the cluster-supporting line, centered at each point's projection, using the normal distribution (μ=0, σ=lateral_disp). This is done by the CluGen.clupoints_n_1() function.\n\"n\": Final points are placed around their projection on the cluster-supporting line using the normal distribution (μ=0, σ=lateral_disp). This is done by the CluGen.clupoints_n() function.\nUser-defined function: The user can specify a custom point placement strategy by passing a function with the same signature as CluGen.clupoints_n_1() and CluGen.clupoints_n().\nclusizes_fn: Distribution of cluster sizes. By default, cluster sizes are determined by the CluGen.clusizes() function, which uses the normal distribution (μ=num_points/num_clusters, σ=μ/3), and assures that the final cluster sizes add up to num_points. This parameter allows the user to specify a custom function for this purpose, which must follow CluGen.clusizes()'s signature. Note that custom functions are not required to strictly obey the num_points parameter.\nclucenters_fn: Distribution of cluster centers. By default, cluster centers are determined by the CluGen.clucenters() function, which uses the uniform distribution, and takes into account the num_clusters and cluster_sep parameters for generating well-distributed cluster centers. This parameter allows the user to specify a custom function for this purpose, which must follow CluGen.clucenters()'s signature.\nllengths_fn: Distribution of line lengths. By default, the lengths of cluster-supporting lines are determined by the CluGen.llengths() function, which uses the folded normal distribution (μ=llength, σ=llength_disp). This parameter allows the user to specify a custom function for this purpose, which must follow CluGen.llengths()'s signature.\nangle_deltas_fn: Distribution of line angle differences with respect to direction. By default, the angles between the main direction of each cluster and the final directions of their cluster-supporting lines are determined by the CluGen.angle_deltas() function, which uses the wrapped normal distribution (μ=0, σ=angle_disp) with support in the interval left-pi2pi2right. This parameter allows the user to specify a custom function for this purpose, which must follow CluGen.angle_deltas()'s signature.\nrng: A concrete instance of AbstractRNG for reproducible runs. Alternatively, the user can set the global RNG seed with Random.seed!() before invoking clugen().\n\nReturn values\n\nThe function returns a NamedTuple with the following fields:\n\npoints: A num_points x num_dims matrix with the generated points for  all clusters.\nclusters: A num_points x 1 vector indicating which cluster each point in points belongs to.\nprojections: A num_points x num_dims matrix with the point projections on the cluster-supporting lines.\nsizes: A num_clusters x 1 vector with the number of points in each cluster.\ncenters: A num_clusters x num_dims matrix with the coordinates of the cluster centers.\ndirections: A num_clusters x num_dims matrix with the final direction of each cluster-supporting line.\nangles: A num_clusters x 1 vector with the angles between the cluster-supporting lines and the main direction.\nlengths: A num_clusters x 1 vector with the lengths of the cluster-supporting lines.\n\nNote that if a custom function was given in the clusizes_fn parameter, it is possible that num_points may have a different value than what was specified in clugen's num_points parameter.\n\nExamples\n\njulia> # Create 5 clusters in 3D space with a total of 10000 points...\n\njulia> out = clugen(3, 5, 10000, [0.5, 0.5, 0.5], pi/16, [10, 10, 10], 10, 1, 2);\n\njulia> out.centers # What are the cluster centers?\n5×3 Matrix{Float64}:\n   8.12774  -16.8167    -1.80764\n   4.30111   -1.34916  -11.209\n -22.3933    18.2706    -2.6716\n -11.568      5.87459    4.11589\n -19.5565   -10.7151   -12.2009\n\nThe following instruction displays a scatter plot of the clusters in 3D space:\n\njulia> plot(out.points[:,1], out.points[:,2], out.points[:,3], seriestype = :scatter, group=out.point_clusters)\n\nCheck the Examples section for a number of illustrative examples on how to use the clugen() function. The Theory section provides more information on how the function works and the impact each parameter has on the final result.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Core-functions","page":"Reference","title":"Core functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Core functions perform a number of useful operations during several steps of the algorithm. These functions may be useful in other contexts, and are thus exported by the package.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"points_on_line\nrand_ortho_vector\nrand_unit_vector\nrand_vector_at_angle","category":"page"},{"location":"reference/#CluGen.points_on_line","page":"Reference","title":"CluGen.points_on_line","text":"points_on_line(\n    center::AbstractArray{<:Real, 1},\n    direction::AbstractArray{<:Real, 1},\n    dist_center::AbstractArray{<:Real, 1}\n) -> AbstractArray{<:Real, 2}\n\nDetermine coordinates of points on a line with center and direction, based on the distances from the center given in dist_center.\n\nThis works by using the vector formulation of the line equation assuming direction is a n-dimensional unit vector. In other words, considering mathbfd= direction (n times 1), mathbfc= center (n times 1), and mathbfw= dist_center (p times 1), the coordinates of points on the line are given by:\n\nmathbfP=mathbf1mathbfc^T + mathbfwmathbfd^T\n\nwhere mathbfP is the p times n matrix of point coordinates on the line, and mathbf1 is a p times 1 vector with all entries equal to 1.\n\nExamples\n\njulia> points_on_line([5.0,5.0], [1.0,0.0], -4:2:4) # 2D, 5 points\n5×2 Matrix{Float64}:\n 1.0  5.0\n 3.0  5.0\n 5.0  5.0\n 7.0  5.0\n 9.0  5.0\n\njulia> points_on_line([-2.0,0,0,2.0], [0,0,-1.0,0], [10,-10]) # 4D, 2 points\n2×4 Matrix{Float64}:\n -2.0  0.0  -10.0  2.0\n -2.0  0.0   10.0  2.0\n\n\n\n\n\n","category":"function"},{"location":"reference/#CluGen.rand_ortho_vector","page":"Reference","title":"CluGen.rand_ortho_vector","text":"rand_ortho_vector(\n    u::AbstractArray{<:Real, 1};\n    rng::AbstractRNG = Random.GLOBAL_RNG\n) -> AbstractArray{<:Real, 1}\n\nGet a random unit vector orthogonal to u.\n\nNote that u is expected to be a unit vector itself.\n\nExamples\n\njulia> u = normalize([1,2,5.0,-3,-0.2]); # Define a 5D unit vector\n\njulia> v = rand_ortho_vector(u);\n\njulia> ≈(dot(u, v), 0; atol=1e-15) # Vectors orthogonal? (needs LinearAlgebra package)\ntrue\n\njulia> rand_ortho_vector([1,0,0]; rng=MersenneTwister(567)) # 3D, reproducible\n3-element Vector{Float64}:\n  0.0\n -0.717797705156548\n  0.6962517177515569\n\n\n\n\n\n","category":"function"},{"location":"reference/#CluGen.rand_unit_vector","page":"Reference","title":"CluGen.rand_unit_vector","text":"rand_unit_vector(\n    num_dims::Integer;\n    rng::AbstractRNG = Random.GLOBAL_RNG\n) ->  AbstractArray{<:Real, 1}\n\nGet a random unit vector with num_dims dimensions.\n\nExamples\n\njulia> v = rand_unit_vector(4) # 4D\n4-element Vector{Float64}:\n -0.24033021128704707\n -0.032103799230189585\n  0.04223910709972599\n -0.9692402145232775\n\njulia> norm(v) # Check vector magnitude is 1 (needs LinearAlgebra package)\n1.0\n\njulia> rand_unit_vector(2; rng=MersenneTwister(33)) # 2D, reproducible\n2-element Vector{Float64}:\n  0.8429232717309576\n -0.5380337888779647\n\n\n\n\n\n","category":"function"},{"location":"reference/#CluGen.rand_vector_at_angle","page":"Reference","title":"CluGen.rand_vector_at_angle","text":"rand_vector_at_angle(\n    u::AbstractArray{<:Real, 1},\n    angle::Real;\n    rng::AbstractRNG = Random.GLOBAL_RNG\n) ->  AbstractArray{<:Real, 1}\n\nGet a random unit vector which is at angle radians of vector u.\n\nNote that u is expected to be a unit vector itself.\n\nExamples\n\njulia> u = normalize([1,0.5,0.3,-0.1]); # Define a 4D unit vector\n\njulia> v = rand_vector_at_angle(u, pi/4); # pi/4 = 0.7853981... radians = 45 degrees\n\njulia> a = acos(dot(u, v) / (norm(u) * norm(v))) # Angle (radians) between u and v?\n0.7853981633974483\n\njulia> rand_vector_at_angle([0, 1], pi/6; rng=MersenneTwister(456)) # 2D, reproducible\n2-element Vector{Float64}:\n -0.4999999999999999\n  0.8660254037844387\n\n\n\n\n\n","category":"function"},{"location":"reference/#Algorithm-module-functions","page":"Reference","title":"Algorithm module functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The module functions perform a complete step of the cluster generation algorithm, providing the package's out-of-the-box functionality. Users can swap one or more of these when invoking clugen() in order to customize the algorithm to their needs.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Since these functions are specific to the cluster generation algorithm, they are not exported by the package.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"CluGen.angle_deltas\nCluGen.clucenters\nCluGen.clupoints_n_1\nCluGen.clupoints_n\nCluGen.clusizes\nCluGen.llengths","category":"page"},{"location":"reference/#CluGen.angle_deltas","page":"Reference","title":"CluGen.angle_deltas","text":"angle_deltas(\n    num_clusters::Integer,\n    angle_disp::Real;\n    rng::AbstractRNG = Random.GLOBAL_RNG\n) -> AbstractArray{<:Real, 1}\n\nDetermine the angles between the average cluster direction and the cluster-supporting lines. These angles are obtained from a wrapped normal distribution (μ=0, σ=angle_disp) with support in the interval left-pi2pi2right. Note this is different from the standard wrapped normal distribution, the support of which is given by the interval left-pipiright.\n\nThe angle_disp parameter must be specified in radians and results are given in radians in the interval left-pi2pi2right.\n\nThis function is not exported by the package and must be prefixed with CluGen if invoked by user code.\n\nExamples\n\njulia> CluGen.angle_deltas(4, pi/128)\n4-element Vector{Float64}:\n  0.01888791855096079\n -0.027851298321307266\n  0.03274154825228485\n -0.004475798744567242\n\njulia> CluGen.angle_deltas(3, pi/32; rng=MersenneTwister(987)) # Reproducible\n3-element Vector{Float64}:\n  0.08834204306583336\n  0.014678748091943444\n -0.15202559427536264\n\n\n\n\n\n","category":"function"},{"location":"reference/#CluGen.clucenters","page":"Reference","title":"CluGen.clucenters","text":"clucenters(\n    num_clusters::Integer,\n    clu_sep::AbstractArray{<:Real, 1},\n    clu_offset::AbstractArray{<:Real, 1};\n    rng::AbstractRNG = Random.GLOBAL_RNG\n) ->  AbstractArray{<:Real}\n\nDetermine cluster centers using the uniform distribution, taking into account the number of clusters (num_clusters) and the average cluster separation (clu_sep).\n\nMore specifically, let c= num_clusters, mathbfs= clu_sep, mathbfo= clu_offset, n= length(clu_sep) (i.e., number of dimensions). Cluster centers are obtained according to the following equation:\n\nmathbfC=cmathbfU cdot operatornamediag(mathbfs) + mathbf1mathbfo^T\n\nwhere mathbfC is the c times n matrix of cluster centers, mathbfU is an c times n matrix of random values drawn from the uniform distribution between -0.5 and 0.5, and mathbf1 is an c times 1 vector with all entries equal to 1.\n\nThis function is not exported by the package and must be prefixed with CluGen if invoked by user code.\n\nExamples\n\njulia> CluGen.clucenters(4, [10, 50], [0, 0]) # 2D\n4×2 Matrix{Float64}:\n 10.7379   -37.3512\n 17.6206    32.511\n  6.95835   17.2044\n -4.18188  -89.5734\n\njulia> CluGen.clucenters(5, [20, 10, 30], [10, 10, -10]) # 3D\n5×3 Matrix{Float64}:\n -13.136    15.8746      2.34767\n -29.1129   -0.715105  -46.6028\n -23.6334    8.19236    20.879\n   7.30168  -1.20904   -41.2033\n  46.5412    7.3284    -42.8401\n\njulia> CluGen.clucenters(3, [100], [0]; rng=MersenneTwister(121)) # 1D, reproducible\n3×1 Matrix{Float64}:\n  -91.3675026663759\n  140.98964768714384\n -124.90981996579862\n\n\n\n\n\n","category":"function"},{"location":"reference/#CluGen.clupoints_n_1","page":"Reference","title":"CluGen.clupoints_n_1","text":"CluGen.clupoints_n_1(\n    projs::AbstractArray{<:Real, 2},\n    lat_disp::Real,\n    line_len::Real,\n    clu_dir::AbstractArray{<:Real, 1},\n    clu_ctr::AbstractArray{<:Real, 1};\n    rng::AbstractRNG = Random.GLOBAL_RNG\n) -> AbstractArray{<:Real}\n\nGenerate points from their n-dimensional projections on a cluster-supporting line, placing each point on a hyperplane orthogonal to that line and centered at the point's projection, using the normal distribution (μ=0, σ=lat_disp).\n\nThis function's main intended use is by the clugen() function, generating the final points when the point_dist_fn parameter is set to \"n-1\".\n\nThis function is not exported by the package and must be prefixed with CluGen if invoked by user code.\n\nArguments\n\nprojs: Point projections on the cluster-supporting line.\nlat_disp: Standard deviation for the normal distribution, i.e., cluster lateral dispersion.\nline_len: Length of cluster-supporting line (ignored).\nclu_dir: Direction of the cluster-supporting line (unit vector).\nclu_ctr: Center position of the cluster-supporting line (ignored).\nrng: An optional pseudo-random number generator for reproducible executions.\n\nExamples\n\njulia> projs = points_on_line([5.0,5.0], [1.0,0.0], -4:2:4) # Get 5 point projections on a 2D line\n5×2 Matrix{Float64}:\n 1.0  5.0\n 3.0  5.0\n 5.0  5.0\n 7.0  5.0\n 9.0  5.0\n\njulia> CluGen.clupoints_n_1(projs, 0.5, 1.0, [1,0], [0,0]; rng=MersenneTwister(123))\n5×2 Matrix{Float64}:\n 1.0  5.59513\n 3.0  3.97591\n 5.0  4.42867\n 7.0  5.22971\n 9.0  4.80166\n\n\n\n\n\n","category":"function"},{"location":"reference/#CluGen.clupoints_n","page":"Reference","title":"CluGen.clupoints_n","text":"GluGen.clupoints_n(\n    projs::AbstractArray{<:Real, 2},\n    lat_disp::Real,\n    line_len::Real,\n    clu_dir::AbstractArray{<:Real, 1},\n    clu_ctr::AbstractArray{<:Real, 1};\n    rng::AbstractRNG = Random.GLOBAL_RNG\n) -> AbstractArray{<:Real}\n\nGenerate points from their n-dimensional projections on a cluster-supporting line, placing each point around its projection using the normal distribution (μ=0, σ=lat_disp).\n\nThis function's main intended use is by the clugen() function, generating the final points when the point_dist_fn parameter is set to \"n\".\n\nThis function is not exported by the package and must be prefixed with CluGen if invoked by user code.\n\nArguments\n\nprojs: Point projections on the cluster-supporting line.\nlat_disp: Standard deviation for the normal distribution, i.e., cluster lateral dispersion.\nline_len: Length of cluster-supporting line (ignored).\nclu_dir: Direction of the cluster-supporting line.\nclu_ctr: Center position of the cluster-supporting line (ignored).\nrng: An optional pseudo-random number generator for reproducible executions.\n\nExamples\n\njulia> projs = points_on_line([5.0,5.0], [1.0,0.0], -4:2:4) # Get 5 point projections on a 2D line\n5×2 Matrix{Float64}:\n 1.0  5.0\n 3.0  5.0\n 5.0  5.0\n 7.0  5.0\n 9.0  5.0\n\njulia> CluGen.clupoints_n(projs, 0.5, 1.0, [1,0], [0,0]; rng=MersenneTwister(123))\n5×2 Matrix{Float64}:\n 1.59513  4.66764\n 4.02409  5.49048\n 5.57133  4.96226\n 7.22971  5.13691\n 8.80166  4.90289\n\n\n\n\n\n","category":"function"},{"location":"reference/#CluGen.clusizes","page":"Reference","title":"CluGen.clusizes","text":"clusizes(\n    num_clusters::Integer,\n    num_points::Integer,\n    allow_empty::Bool;\n    rng::AbstractRNG = Random.GLOBAL_RNG\n) -> AbstractArray{<:Integer, 1}\n\nDetermine cluster sizes, i.e., the number of points in each cluster, using the normal distribution (μ=num_points/num_clusters, σ=μ/3), and then assuring that the final cluster sizes add up to num_points via the CluGen.fix_num_points!() function.\n\nThis function is not exported by the package and must be prefixed with CluGen if invoked by user code.\n\nExamples\n\njulia> CluGen.clusizes(4, 6, true)\n4-element Vector{Int64}:\n 1\n 0\n 3\n 2\n\njulia> CluGen.clusizes(4, 100, false)\n4-element Vector{Int64}:\n 29\n 26\n 24\n 21\n\njulia> CluGen.clusizes(5, 500, true; rng=MersenneTwister(123)) # Reproducible\n5-element Vector{Int64}:\n 108\n 129\n 107\n  89\n  67\n\n\n\n\n\n","category":"function"},{"location":"reference/#CluGen.llengths","page":"Reference","title":"CluGen.llengths","text":"llengths(\n    num_clusters::Integer,\n    llength::Real,\n    llength_disp::Real;\n    rng::AbstractRNG = Random.GLOBAL_RNG\n) -> AbstractArray{<:Real, 1}\n\nDetermine length of cluster-supporting lines using the folded normal distribution (μ=llength, σ=llength_disp).\n\nThis function is not exported by the package and must be prefixed with CluGen if invoked by user code.\n\nExamples\n\njulia> CluGen.llengths(5, 10, 3)\n5-element Vector{Float64}:\n 13.57080364295883\n 16.14453912336772\n 13.427952708601596\n 11.37824686122124\n  8.809962762114331\n\njulia> CluGen.llengths(3, 100, 60; rng=MersenneTwister(111)) # Reproducible\n3-element Vector{Float64}:\n 146.1737820482947\n  31.914161161783426\n 180.04064126207396\n\n\n\n\n\n","category":"function"},{"location":"reference/#Helper-functions","page":"Reference","title":"Helper functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The helper functions provide useful or reusable functionality, mainly to the module functions described in the previous section. This reusable functionality may be useful for users implementing their own customized module functions.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Except for angle_btw(), these functions are not exported by the package since their use is limited to advanced algorithm customization scenarios.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"angle_btw\nCluGen.clupoints_n_1_template\nCluGen.fix_empty!\nCluGen.fix_num_points!","category":"page"},{"location":"reference/#CluGen.angle_btw","page":"Reference","title":"CluGen.angle_btw","text":"angle_btw(v1::AbstractArray{<:Real, 1}, v2::AbstractArray{<:Real, 1}) -> Real\n\nAngle between two n-dimensional vectors.\n\nTypically, the angle between two vectors v1 and v2 can be obtained with:\n\nacos(dot(v1, v2) / (norm(v1) * norm(v2)))\n\nHowever, this approach is numerically unstable. The version provided here is numerically stable and based on the AngleBetweenVectors.jl package by Jeffrey Sarnoff (MIT license), implementing an algorithm provided by Prof. W. Kahan in these notes (see page 15).\n\nExamples\n\njulia> rad2deg(angle_btw([1.0, 1.0, 1.0, 1.0], [1.0, 0.0, 0.0, 0.0]))\n60.00000000000001\n\n\n\n\n\n","category":"function"},{"location":"reference/#CluGen.clupoints_n_1_template","page":"Reference","title":"CluGen.clupoints_n_1_template","text":"CluGen.clupoints_n_1_template(\n    projs::AbstractArray{<:Real, 2},\n    lat_disp::Real,\n    clu_dir::AbstractArray{<:Real, 1},\n    dist_fn::Function;\n    rng::AbstractRNG = Random.GLOBAL_RNG\n) -> AbstractArray{<:Real}\n\nGenerate points from their n-dimensional projections on a cluster-supporting line, placing each point on a hyperplane orthogonal to that line and centered at the point's projection. The function specified in dist_fn is used to perform the actual placement.\n\nThis function is used internally by CluGen.clupoints_n_1() and may be useful for constructing user-defined final point placement strategies for the point_dist_fn parameter of the main clugen() function.\n\nThis function is not exported by the package and must be prefixed with CluGen if invoked by user code.\n\nArguments\n\nprojs: Point projections on the cluster-supporting line.\nlat_disp: Dispersion of points from their projection.\nclu_dir: Direction of the cluster-supporting line (unit vector).\ndist_fn: Function to place points on a second line, orthogonal to the first. The functions accepts as parameters the number of points in the current cluster, the lateral_disp parameter (the same passed to the clugen() function), and a random number generator, returning a vector containing the distance of each point to its projection on the cluster-supporting line.\nrng: An optional pseudo-random number generator for reproducible executions.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CluGen.fix_empty!","page":"Reference","title":"CluGen.fix_empty!","text":"fix_empty!(\n    clu_num_points::AbstractArray{<:Integer, 1},\n    allow_empty::Bool = false\n) -> AbstractArray{<:Integer, 1}\n\nCertifies that, given enough points, no clusters are left empty. This is done by removing a point from the largest cluster and adding it to an empty cluster while there are empty clusters. If the total number of points is smaller than the number of clusters (or if the allow_empty parameter is set to true), this function does nothing.\n\nThis function is used internally by CluGen.clusizes() and might be useful for custom cluster sizing implementations given as the clusizes_fn parameter of the main clugen() function.\n\nThis function is not exported by the package and must be prefixed with CluGen if invoked by user code.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CluGen.fix_num_points!","page":"Reference","title":"CluGen.fix_num_points!","text":"fix_num_points!(\n    clu_num_points::AbstractArray{<:Integer, 1},\n    num_points::Integer\n) -> AbstractArray{<:Integer, 1}\n\nCertifies that the values in the clu_num_points array, i.e. the number of points in each cluster, add up to num_points. If this is not the case, the clu_num_points array is modified in-place, incrementing the value corresponding to the smallest cluster while sum(clu_num_points) < num_points, or decrementing the value corresponding to the largest cluster while sum(clu_num_points) > num_points.\n\nThis function is used internally by CluGen.clusizes() and might be useful for custom cluster sizing implementations given as the clusizes_fn parameter of the main clugen() function.\n\nThis function is not exported by the package and must be prefixed with CluGen if invoked by user code.\n\n\n\n\n\n","category":"function"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CluGen.jl is a Julia implementation of the clugen algorithm for generating multidimensional clusters. Each cluster is supported by a line segment, the position, orientation and length of which guide where the respective points are placed. It provides the clugen() function for this purpose, as well as a number of auxiliary functions, used internally and modularly by clugen(). Users can swap these auxiliary functions by their own customized versions, fine-tuning their cluster generation strategies, or even use them as the basis for their own generation algorithms.","category":"page"},{"location":"#How-to-install","page":"Home","title":"How to install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"From Julia's general registry:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"CluGen\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"From source/GitHub:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"https://github.com/clugen/CluGen.jl\")","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing Random # hide\nRandom.seed!(123) # hide\nusing CluGen, Plots","category":"page"},{"location":"","page":"Home","title":"Home","text":"o = clugen(2, 4, 400, [1, 0], pi / 8, [20, 10], 10, 1, 1.5)\np = plot(o.points[:, 1], o.points[:, 2], seriestype = :scatter, group=o.clusters)\nsavefig(p, \"ex2d_quick.svg\") # hide\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: 2D example)","category":"page"},{"location":"","page":"Home","title":"Home","text":"o = clugen(3, 4, 1000, [1, 0, 1], pi / 8, [20, 15, 25], 16, 4, 3.5)\np = plot(o.points[:, 1], o.points[:, 2], o.points[:, 3], seriestype = :scatter, group=o.clusters)\nsavefig(p, \"ex3d_quick.svg\") # hide\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: 3D example)","category":"page"},{"location":"#Further-reading","page":"Home","title":"Further reading","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The clugen algorithm and its several implementations are detailed in the following reference (please cite it if you use this software):","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fachada, N. & de Andrade, D. (2023). Generating Multidimensional Clusters With Support Lines. https://doi.org/10.48550/arXiv.2301.10327.","category":"page"},{"location":"#Also-on-this-documentation","page":"Home","title":"Also on this documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"theory.md\", \"examples.md\", \"reference.md\", \"dev.md\"]","category":"page"}]
}
